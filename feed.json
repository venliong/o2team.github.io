{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Wed, 19 Jul 2017 08:25:35 GMT","lastBuildDate":"Fri, 21 Jul 2017 01:19:02 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"一篇文章带你快速入门 CreateJS","link":"https://aotu.io/notes/2017/07/19/createjs/","description":"CreateJS 简介 官网：http://www.createjs.cc/ CreateJS 中包含以下四个部分： EaselJS：用于 Sprites 、动画、向量和位图的绘制 TweenJS：用于做动画效果 SoundJS：音频播放引擎 PreloadJS：网站资源预加载 这四个部分都可以单独的引用，可选可不选。 一. 预加载 PreloadJS CreateJS 的 PreloadJS 非常的实用，实现起来也比较简短，如下： 1234567891011//放置静态资源的数组var manifest = [ &#123;src: './images/car_prop2_tyre@2x.png', id: 'tyre'&#125;];var queue = new createjs.LoadQueue();queue.on('complete', handleComplete, this);queue.loadManifest(manifest);//资源加载成功后,进行处理function handleComplete() &#123; var tyre = queue.getResult('tyre'); //获取加载资源&#125; Image 跨域小坑： 有些时候跨域的图片可以成功地使用 Canvas 渲染出来，但是到需要对图片进行某些处理的时候，浏览器就会报错。 “被污染的” Canvas ? 尽管没有 CORS 授权也可以在 Canvas 中使用图像, 但这样做就会污染画布。 只要 Canvas 被污染, 就不能再从画布中提取数据, 也就是说不能再调用 toDataURL() 和 getImageData() 等方法, 否则会抛出安全错误 (security error) 。 解决图片跨域有2种解决方法： 图片所在的服务器设置 Access-Control-Allow-Origin “*” 响应头 手动将 IMG 的 url 转换成当前域名的 url ，详细处理方法 在服务器不支持图片跨域的情况下，我们自己手动将图片转换成同域是比较麻烦的，因此，使用 CreateJS 的 PreloadJS ,将最后一个参数设置为 Anonymous 即可。 12345var queue = new createjs.LoadQueue(false,'','Anonymous'); //LoadQueue ( [preferXHR=true] [basePath=\"\"] [crossOrigin=\"\"] )第一个参数为true，代表通过xhr形式加载.basePath 在加载资源时的，会把basePath加载url前面。这样加载同一个目录下的文件时，可以方便一点。 但是如果url是以协议（如”http://”）或者”../”这样路径开头时，不会添加basePath。crossOrigin 设置为Anonymous的时候，则表示允许跨域 二. EaselJS 的常用 API 画图片用 (Bitmap) 画图形，比如矩形，圆形等用 (Shape) 【类似于改变坐标x，y，增加阴影 Shadow ，透明度 Alpha ，缩小放大 ScaleX/ScaleY 都可以做到】 画文字，用 (Text) 还有容器 Container 的概念，容器可以包含多个显示对象 三. EaselJS 绘图的大致流程 大致流程：创建显示对象→设置一些参数→调用方法绘制→添加到舞台→ update() ，代码如下：1234567891011var canvas = document.querySelector('#canvas');//创建舞台var stage = new createjs.Stage(canvas);//创建一个Shape对象，此处也可以创建文字Text,创建图片Bitmapvar rect = new createjs.Shape();//用画笔设置颜色，调用方法画矩形，矩形参数：x,y,w,hrect.graphics.beginFill(\"#f00\").drawRect(0, 0, 100, 100);//添加到舞台stage.addChild(rect);//刷新舞台stage.update(); graphics 可以设置一些样式，线条宽度，颜色等等，也可以调用一些方法绘制图形，比如矩形 drawRect ，圆形 drawCircle 等等，具体可以自己查看 API。注意：以上的步骤每一步都要有，否则页面不会有绘制的物体。 四. Tick 事件对于有频繁发生改变的物体，如果在每一处变化都刷新舞台的话，代码会比较冗余，因此我们可以写一个 Tick 事件，在每一次 Tick 的时候 update 舞台。123456789createjs.Ticker.addEventListener(“tick”, tick);function tick(e) &#123; if (e.paused === 1) &#123; //处理 stage.update(); //刷新舞台 &#125;else &#123;&#125;&#125;createjs.Ticker.paused = 1; //在函数任何地方调用这个，则会暂停tick里面的处理createjs.Ticker.paused = 0; //恢复游戏 在暂停的时候，页面仍会触发 Tick 事件，如果需要完全移除 Tick 事件，则使用 1createjs.Ticker.removeEventListener(\"tick\", tick); 五. Ticker 帧频率上面说的 Tick 事件，每一次触发的频率是可以修改的。理想的帧频率是 60FPS。1createjs.Ticker.setFPS(60); 六. CreateJS 的渲染模式CreateJs 提供了两种渲染模式，一种是用 setTimeout ，一种是用 requestAnimationFrame ，默认是 setTimeout ，默认的帧数是 20 ，一般的话还没有什么区别，但是如果动画多的话，设置成 requestAnimationFrame 模式的话，就会感觉到动画如丝般的流畅。1createjs.Ticker.timingMode = createjs.Ticker.RAF; 使用这种模式，则会忽略 Ticker 的帧频 FPS 。 七. CreateJS 事件EaselJS 事件默认是不支持 Touch 设备的，需要以下代码才支持：1createjs.Touch.enable(stage); 对于 Bitmap， Shape 等对象，都可以直接使用 addEventListener 进行事件监听。12bitmap = new createjs.Bitmap('');bitmap.addEventListener（‘click’，handle）; 八. 优化对所绘制物体的控制能力 控制多个显示对象的层级关系 Stage ， Container 对象有个 Children 属性代表子元素，是一个数组，里面的元素层级像下标一样从 0 开始，简单来说就是后面的覆盖前面的（类似于z-index）,后 addChild 的对象则在数组的后面。我们也可以动态改变 Children 的层叠效果。1obj.parent.setChildIndex(obj, n); //n为设置的层级 利用容器 Container 它可以包含 Text 、 Bitmap 、 Shape 、 Sprite 等其他的 EaselJS 元素，包含在一个 Container 中方便统一管理。比如一辆汽车由汽车本身，气泡提示，加速效果，减速效果组成，我们可以将这几个部分放在同一个 Container 中，统一移动。使用方法也比较简单：1234var contain = new createjs.Container();contain.addChild(bgImg);contain.addChild(bitmap);stage.addChild(contain); 我们在后期会频繁对这个 Container 里面的元素进行操作，比如展示加速效果，取消展示减速效果。那我们可以给这些元素设置name属性，之后可以直接使用 getChildByName 获取到该对象。123bitmap.name = ‘quick’; //设置name值quick = this.stage.getChildByName(“quick”); //使用name值方便获取到该对象quick.visible = true; //显示该效果 九. 绘制图像并对图像进行操作 绘制图片123var bg = new createjs.Bitmap(\"./background.png\");stage.addChild(bg);stage.update(); 按照上面的 EaselJS 的正常的绘制流程来说，上面这段代码应该可以正常显示。但是，只是有些情况下可以正常显示的，这个图像资源需要确定加载成功后才可以 new ，否则不会有图像在画布上，如果有做资源预加载，可以直接使用上面的代码，如果没有，则需要在 Image 加载完成 Onload 之后才进行绘制。1234567var img = new Image();img.src = './img/linkgame_pass@2x.png';img.onload = function () &#123; var bg = new createjs.Bitmap(\"./background.png\"); stage.addChild(bg); stage.update();&#125; 仅仅绘制图片是不够的， CreateJS 提供了几种处理图片的方法： 给图片增加遮罩层使用 mask 属性，可以只显示图片和 shape 相交的区域12345678910111213stage = new createjs.Stage(\"gameView\");bg = new createjs.Bitmap(\"./img/linkgame_pass@2x.png\");bg.x = 10;bg.y = 10;//遮罩图形shape = new createjs.Shape();shape.graphics.beginFill(\"#000\").drawCircle(0, 0, 100);shape.x = 200;shape.y = 100;bg.mask = shape; //给图片bg添加遮罩stage.addChild(shape);stage.addChild(bg);stage.update(); 常用应用场景：用来剪裁图片，比如显示圆形的图片等 给图片增加滤镜效果12var blur = new createjs.BlurFilter(5,5,1);bg.filters = [blur]; 我们发现，图片还是没有变模糊，原因是图片添加了 Filter 后 Stage 立即刷新， Filter 只能保持一帧的效果，第二帧 Filter 则失效了。而使用图片的 cache() 方法后，可以使得无论舞台怎么刷新，都可以保持住 Filter 的效果，添加 cache 还有很多作用，可以提高 FPS ，缓存等1bg.cache(0,0,bg.image.width,bg.image.height); 使用 Rectangle 剪裁图片使用 EaselJS 内置的 Rectangle 对象来创建一个选取框，显示图片的某各部分。12345678stage = new createjs.Stage(\"gameView\");bg = new createjs.Bitmap(\"./img/linkgame_pass@2x.png\");bg.x = 10;bg.y = 10;var rect = new createjs.Rectangle(0, 0, 121, 171);bg.sourceRect = rect;stage.addChild(bg);stage.update(e); 适用场景：拼图小游戏，剪裁图片…… 具体的使用方法我们都知道啦，接下来用一个小 Demo 练练手 – 实现一个无缝连接的背景图，模拟汽车加速的状态 1234567891011121314151617181920212223242526272829this.backdrop = new createjs.Bitmap(bg);this.backdrop.x = 0;this.backdrop.y = 0;this.stage.addChild(that.backdrop);this.w = bg.width;this.h = bg.height;//创建一个背景副本，无缝连接var copyy = -bg.height;this.copy = new createjs.Bitmap(bg);this.copy.x = 0;this.copy.y = copyy; //在画布上 y 轴的坐标为负的背景图长//使用 CreateJS 的 Tick 函数，逐帧刷新舞台createjs.Ticker.addEventListener(\"tick\", tick);function tick(e) &#123; if (e.paused !== 1) &#123; //舞台逐帧逻辑处理函数 that.backdrop.y = that.speed + that.backdrop.y; that.copy.y = that.speed + that.copy.y; if (that.copy.y &gt; -40) &#123; that.backdrop.y = that.copy.y + copyy; &#125; if (that.copy.y &gt; -copyy - 100) &#123; that.copy.y = copyy + that.backdrop.y; &#125; &#125; that.stage.update(e);&#125; demo体验链接： http://jdc.jd.com/fd/h5/peidan/demo/car.html 总结整篇文章介绍了下面几个部分 详细介绍了 CreateJS 的常用 API CreateJS 的一些常见 bug 及解决方法 CreateJS 实现小 Demo 参考： https://github.com/pfan123/code-snippet/issues/10 如何使用 CreateJS 来编写HTML5游戏（一）EaselJS简介 如何使用 CreateJS 来编写HTML5游戏（二）使用EaselJS处理图片 如何使用 CreateJS 来编写HTML5游戏（三）使用EaselJS中的制作Sprite类制作 如何使用 CreateJS 来编写HTML5游戏（四）TweenJS和Tick动画 如何使用 CreateJS 来编写HTML5游戏（五）PreloadJS和SoundJS 如何使用 CreateJS 来编写HTML5游戏（六）完成一个简单的打飞机游戏（上） 如何使用 CreateJS 来编写HTML5游戏（七）完成一个简单的打飞机游戏（下）","pubDate":"Wed, 19 Jul 2017 08:25:35 GMT","guid":"https://aotu.io/notes/2017/07/19/createjs/","category":"移动开发"},{"title":"Vue 探索与实践","link":"https://aotu.io/notes/2017/07/17/The-Exploration-and-Practice-of-Vue/","description":"本文主要讲了实际业务在结合 vue 开发的过程中的探索与实践。","pubDate":"Mon, 17 Jul 2017 07:04:31 GMT","guid":"https://aotu.io/notes/2017/07/17/The-Exploration-and-Practice-of-Vue/","category":"项目总结"},{"title":"实现一个 Swiper","link":"https://aotu.io/notes/2017/07/17/design-a-swiper/","description":"设计一个五图的 Swiper，设计稿如下： Swiper 的功能如下： 左右切换 无限轮播 任意图片数 接下来，详细介绍这三个功能的实现过程： 左右切换这里指触发左右切换的手指交互，目前主要是以下两种： 方案 示意图 手指拖拽 手势判断 手指拖拽容易有性能问题并且实现相对麻烦，所以笔者果断采用了手势判断，伪代码如下： 123456789101112131415swiper.on(\"touchstart\", startHandle); swiper.on(\"touchmove\", moveHandle); function startHandle(e) &#123; var x0 = e.touch.pageX, y0 = e.touch.pageY; &#125;function moveHandle(e) &#123; var x = e.touch.pageX, y = e.touch.pageY, offsetX = x0 - x, offsetY = y0 - y; if(offsetX &lt;= -50) &#123; // 向右 // to do &#125; else if(offsetX &gt;= 50) &#123; // 向左 // to do &#125; &#125; 无限轮播无限轮播要面对的是两个问题： 轮播的数据结构； 前端渲染 数据结构无限轮播笔者联想到旋转木马。 在数据结构中有一个叫循环链表的结构，可以完美地模拟旋转木马。 javascript 没有指针，链表需要由数组来模拟。分析循环链表的两个重点特征： 数据项都由头指针访问 链表头尾有指针串联 笔者用 pop&amp;unshift/shift&amp;push APIs 模拟指针的前后移动，解决了链表头尾串联的问题，然后用数组的第一个元素（Arrayy[0]）作为头指针。 伪代码如下： 12345678if(left) &#123; queue.push(this.queue.shift()); swap(\"left\"); // 渲染&#125;else &#123; queue.unshift(this.queue.pop()); swap(\"right\"); // 渲染&#125; 前端渲染swiper 换个角度来看，它其实是一个金字塔： 梳理好层级问题再把过渡补间写上，swiper 的渲染就已经OK了。以下是伪代码： 123456789101112131415function swap() &#123; // queue 循环链表 // nodelist 图片列表 for(var i=0; i&lt;5; ++i) &#123; nodelist[queue[i]].style.cssText = css[i]; &#125;&#125;// 层级与补间css = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // pic2 \"z-index: 1; other css...\", // pic3 \"z-index: 1; other css...\", // pic4 \"z-index: 2; other css...\" // pic5]; 任意图片数图片数可以分成三种情况来讨论：count == 5; count &gt; 5; count &lt; 5。其中 count == 5 是理想条件，上几节就是围绕它展开的。本节将分析 count &gt; 5 与 count &lt; 5 的解决思路。 count &gt; 5将循环链表（5节）扩容： 扩容后的工作过程如下： 循环链表指针移动； 渲染节点（1, 2, 3, n-1, n）； 回收节点（4, 5, …, n-2）。 注：这里的回收节点指隐藏节点（display: none/visibility: hidden） 渲染金字塔如下： 为了提高性能笔者在循环链表与节点中间创建了一个快照数组 snapshot，snapshot 映射节点上的属性，循环链表每一次变动都会生成一个新的快照数组 nextSnap，通过 nextSnap 来更新 snapshot 与 节点样式。以下是实现的伪代码： 12345678910111213141516171819202122232425262728293031323334353637// 初始化function init() &#123; nodelist = document.querySelectorAll(\"li\"); // nodelist n = nodelist.length; queue = [0, 1, 2, ..., n]; // 循环链表 snapshot = new Array(n); // 映射 nodelist 的快照 // 初始化 nodelist 样式 for(var i=0; i&lt;n; ++i) &#123; nodelist[i].style.cssText = defaultCssText; &#125;&#125;// 缺省样式 var defaultCssText = \"visibility: hidden\"; // 层级与补间css = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // pic2 \"z-index: 1; other css...\", // pic3 \"z-index: 1; other css...\", // pic(n-1) \"z-index: 2; other css...\" // picn]; // 切换渲染 function swap() &#123; nextSnap = new Array(n); // swiper切换后的快照 for(var i in [0, 1, 2, n-1, n]) &#123; nextSnap[queue[i]] = css[i]; &#125; // 更新 snapshot 与 nodelist for(var i=0; i&lt;n; ++i) &#123; if(snapshot[i] != nextSnap[i]) &#123; // 快照更新 snapshort[i] = nextSnap[i]; // 样式更新 nodelist[i].style.cssText = snapshort[i] || defaultCssText); &#125; &#125;&#125; count &lt; 5当count &gt;= 5时，渲染节点是一个稳定的金字塔： 当 count &lt; 5时，渲染金字塔变得不确定： count 金字塔 1 2 3 4 由于只有 count == 1 ~ 4 四种情况，可以直接用个 swith 把状态列表出来： 1234567891011121314151617181920212223242526272829303132// 层级与补间css1 = [ \"z-index: 1; other css...\", // pic1]css2 = [ \"z-index: 2; other css...\", // pic1 \"z-index: 1; other css...\" // pic2] css3 = [ \"z-index: 2; other css...\", // pic1 \"z-index: 1; other css...\", // pic2 \"z-index: 1; other css...\" // pic3] css4 = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // pic2 \"z-index: 2; other css...\", // pic3 \"z-index: 1; other css...\" // pic4] switch(n) &#123; case 4: css = css4, renderList = [1, 4, 2, 3], break; case 3: css = css3, renderList = [1, 3, 2], break; case 2: css = css2, renderList = [1, 2], break; default: css = css1, renderList = [1], break; &#125;function swap() &#123; // queue 循环链表 // nodelist 图片列表 for(var i in renderList) &#123; nodelist[queue[renderList[i]]].style.cssText = css[i]; &#125;&#125; 上面的伪代码显得很冗长，并不是个好实现方式。不过仍能从上面代码获得启发: 渲染列表(renderList) 与循环链表(queue)的对应关系 —— [shift, pop, shift, pop, shift]。于是伪代码可以简化为： 12345678910111213141516171819function swap() &#123; // queue 循环链表 // renderList 渲染列表 while(queue.length &gt; 0 &amp;&amp; renderList.length &lt; 5) &#123; renderList.push(renderList.length % 2 ? queue.pop() : queue.shift()); &#125; // nodelist 图片列表 for(var i=0; i&lt;renderList.length; ++i) &#123; nodelist[queue[i]].style.cssText = css[i]; &#125;&#125; // 层级与补间css = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // picn \"z-index: 2; other css...\", // pic2 \"z-index: 1; other css...\", // pic(n-1) \"z-index: 1; other css...\" // pic3]; 细节优化笔者实现的 swiper: https://leeenx.github.io/mobile-swiper/v1.html (count &gt;= 5)运行效果如下： 仔细观察能看到切换效果上的小瑕疵： 造成这个瑕疵是因为同值 z-index 节点的渲染层级与 DOM 树的出现顺序相关： 后出现的节点层级更高。 解决方案很简单，为 swiper 添加一个 translateZ 。如下伪代码： 12345678910// 支持 3d 透视swiper.style[\"-webkit-transform-style\"] = \"preserve-3d\"; // 层级与补间css = [ \"z-index: 3; transfomr: translateZ(10px)\", // pic1 \"z-index: 2; transfomr: translateZ(6px)\", // picn \"z-index: 2; transfomr: translateZ(6px)\", // pic2 \"z-index: 1; transfomr: translateZ(2px)\", // pic(n-1) \"z-index: 1; transfomr: translateZ(2px)\" // pic3]; 添加 z-index 后的swiper: https://leeenx.github.io/mobile-swiper/v2.html 再看看 count &lt; 5 的运行效果： count 效果图 地址 1 https://leeenx.github.io/mobile-swiper/v2.html?count=1 2 https://leeenx.github.io/mobile-swiper/v2.html?count=2 3 https://leeenx.github.io/mobile-swiper/v2.html?count=3 4 https://leeenx.github.io/mobile-swiper/v2.html?count=4 当 count == 2 / count == 4 时，swiper 向右切换时怪怪的，总感觉有什么不对！！其实问题出在渲染金字塔上，偶数swiper 在视觉在不是一个对称的图形： 由于笔者使用定势渲染的原因造成金字塔底被固定在左侧，当向右侧切换时会觉得很奇怪。这里其实只要加一个方向修正即可，以下是修正的伪代码： 1234567891011121314function swap(orientation) &#123; odd = 1; // 奇偶标记 total = queue.length; // 渲染列表长度 last = total - 1; // renderList 最后一个索引 while(queue.length &gt; 0 &amp;&amp; renderList.length &lt; 5) &#123; renderList.push(odd ? queue.pop() : queue.shift()); odd = !odd; // 取反 &#125; // nodelist 图片列表 for(var i=0; i&lt;5; ++i) &#123; // 偶数并且向右切换，将最后一个节点右置 nodelist[queue[i]].style.cssText = (orientation == \"right\" &amp;&amp; !odd &amp;&amp; i == last) ? css[i+1] : css[i]; &#125;&#125; 修复后的效果如下： count 效果图 地址 2 https://leeenx.github.io/mobile-swiper/index.html?count=2 4 https://leeenx.github.io/mobile-swiper/index.html?count=4 总结感谢阅读完本文章的读者。本文最终实现的 swiper 笔者托管在 Github 仓库，有兴趣的读者可以看一下：https://github.com/leeenx/mobile-swiper 希望对你们有帮助。","pubDate":"Mon, 17 Jul 2017 05:23:19 GMT","guid":"https://aotu.io/notes/2017/07/17/design-a-swiper/","category":"Web开发"},{"title":"2D圆形随机分布","link":"https://aotu.io/notes/2017/07/10/Random-Circles/","description":"如何画出又快又多的圈圈。","pubDate":"Mon, 10 Jul 2017 02:11:34 GMT","guid":"https://aotu.io/notes/2017/07/10/Random-Circles/","category":"Web开发"},{"title":"用Web技术实现移动监测","link":"https://aotu.io/notes/2017/06/29/motion-detection/","description":"本文将阐述如何通过 Web 技术实现简易的移动监测效果，并附上一些有意思的案例。 移动侦测，英文翻译为“Motion detection technology”，一般也叫运动检测，常用于无人值守监控录像和自动报警。通过摄像头按照不同帧率采集得到的图像会被 CPU 按照一定算法进行计算和比较，当画面有变化时，如有人走过，镜头被移动，计算比较结果得出的数字会超过阈值并指示系统能自动作出相应的处理。——百度百科 由上述引用语句可得出“移动监测”需要以下要素： 一个拥有摄像头的计算机 用于判断移动的算法 移动后的处理 注：本文涉及的所有案例均基于 PC/Mac 较新版本的 Chrome / Firefox 浏览器，部分案例需配合摄像头完成，所有截图均保存在本地。 对方不想和你说话，并向你扔来一个链接： 体验链接&gt;&gt; 综合案例 该案例有以下两个功能： 拍好 POST 后的 1 秒会进行拍照 静止 1 秒后音乐会停止，产生移动会恢复播放状态 上述案例也许并不能直接体现出『移动监测』的实际效果和原理，下面再看看这个案例。 体验链接&gt;&gt; 像素差异 案例的左侧是视频源，而右侧则是移动后的像素处理（像素化、判断移动和只保留绿色等）。 因为是基于 Web 技术，所以视频源采用 WebRTC，像素处理则采用 Canvas。 视频源不依赖 Flash 或 Silverlight，我们使用 WebRTC (Web Real-Time Communications) 中的 navigator.getUserMedia() API，该 API 允许 Web 应用获取用户的摄像头与麦克风流（stream）。 示例代码如下：1234567891011121314151617181920&lt;!-- 若不加 autoplay，则会停留在第一帧 --&gt;&lt;video id=\"video\" autoplay&gt;&lt;/video&gt;// 具体参数含义可看相关文档。const constraints = &#123; audio: false, video: &#123; width: 640, height: 480 &#125;&#125;navigator.mediaDevices.getUserMedia(constraints) .then(stream =&gt; &#123; // 将视频源展示在 video 中 video.srcObject = stream &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) 对于兼容性问题，Safari 11 开始支持 WebRTC 了。具体可查看 caniuse。 像素处理在得到视频源后，我们就有了判断物体是否移动的素材。当然，这里并没有采用什么高深的识别算法，只是利用连续两帧截图的像素差异来判断物体是否发生移动（严格来说，是画面的变化）。 截图获取视频源截图的示例代码：123456789101112const video = document.getElementById('video')const canvas = document.createElement('canvas')const ctx = canvas.getContext('2d')canvas.width = 640canvas.height = 480// 获取视频中的一帧function capture () &#123; ctx.drawImage(video, 0, 0, canvas.width, canvas.height) // ...其它操作&#125; 得出截图间的差异对于两张图的像素差异，在 凹凸实验室 的 《“等一下，我碰！”——常见的2D碰撞检测》 这篇博文中所提及的“像素检测”碰撞算法是解决办法之一。该算法是通过遍历两个离屏画布（offscreen canvas）同一位置的像素点的透明度是否同时大于 0，来判断碰撞与否。当然，这里要改为『同一位置的像素点是否不同（或差异小于某阈值）』来判断移动与否。 但上述方式稍显麻烦和低效，这里我们采用 ctx.globalCompositeOperation = &#39;difference&#39; 指定画布新增元素（即第二张截图与第一张截图）的合成方式，得出两张截图的差异部分。 体验链接&gt;&gt; 示例代码：1234567891011function diffTwoImage () &#123; // 设置新增元素的合成方式 ctx.globalCompositeOperation = 'difference' // 清除画布 ctx.clearRect(0, 0, canvas.width, canvas.height) // 假设两张图像尺寸相等 ctx.drawImage(firstImg, 0, 0) ctx.drawImage(secondImg, 0, 0)&#125; 两张图的差异 体验上述案例后，是否有种当年玩“QQ游戏《大家来找茬》”的感觉。另外，这个案例可能还适用于以下两种情况： 当你不知道设计师前后两次给你的设计稿有何差异时 想查看两个浏览器对同一个网页的渲染有何差异时 何时为一个“动作”由上述“两张图像差异”的案例中可得：黑色代表该位置上的像素未发生改变，而像素越明亮则代表该点的“动作”越大。因此，当连续两帧截图合成后有明亮的像素存在时，即为一个“动作”的产生。但为了让程序不那么“敏感”，我们可以设定一个阈值。当明亮像素的个数大于该阈值时，才认为产生了一个“动作”。当然，我们也可以剔除“不足够明亮”的像素，以尽可能避免外界环境（如灯光等）的影响。 想要获取 Canvas 的像素信息，需要通过 ctx.getImageData(sx, sy, sw, sh)，该 API 会返回你所指定画布区域的像素对象。该对象包含 data、width、height。其中 data 是一个含有每个像素点 RGBA 信息的一维数组，如下图所示。 含有 RGBA 信息的一维数组 获取到特定区域的像素后，我们就能对每个像素进行处理（如各种滤镜效果）。处理完后，则可通过 ctx.putImageData() 将其渲染在指定的 Canvas 上。 扩展：由于 Canvas 目前没有提供“历史记录”的功能，如需实现“返回上一步”操作，则可通过 getImageData 保存上一步操作，当需要时则可通过 putImageData 进行复原。 示例代码：1234567891011121314151617181920let imageScore = 0const rgba = imageData.datafor (let i = 0; i &lt; rgba.length; i += 4) &#123; const r = rgba[i] / 3 const g = rgba[i + 1] / 3 const b = rgba[i + 2] / 3 const pixelScore = r + g + b // 如果该像素足够明亮 if (pixelScore &gt;= PIXEL_SCORE_THRESHOLD) &#123; imageScore++ &#125;&#125;// 如果明亮的像素数量满足一定条件if (imageScore &gt;= IMAGE_SCORE_THRESHOLD) &#123; // 产生了移动&#125; 在上述案例中，你也许会注意到画面是『绿色』的。其实，我们只需将每个像素的红和蓝设置为 0，即将 RGBA 的 r = 0; b = 0 即可。这样就会像电影的某些镜头一样，增加了科技感和神秘感。 体验地址&gt;&gt; 示例代码：12345678const rgba = imageData.datafor (let i = 0; i &lt; rgba.length; i += 4) &#123; rgba[i] = 0 // red rgba[i + 2] = 0 // blue&#125;ctx.putImageData(imageData, 0, 0) 将 RGBA 中的 R 和 B 置为 0 跟踪“移动物体”有了明亮的像素后，我们就要找出其 x 坐标的最小值与 y 坐标的最小值，以表示跟踪矩形的左上角。同理，x 坐标的最大值与 y 坐标的最大值则表示跟踪矩形的右下角。至此，我们就能绘制出一个能包围所有明亮像素的矩形，从而实现跟踪移动物体的效果。 找出跟踪矩形的左上角和右下角 体验链接&gt;&gt; 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function processDiff (imageData) &#123; const rgba = imageData.data let score = 0 let pixelScore = 0 let motionBox = 0 // 遍历整个 canvas 的像素，以找出明亮的点 for (let i = 0; i &lt; rgba.length; i += 4) &#123; pixelScore = (rgba[i] + rgba[i+1] + rgba[i+2]) / 3 // 若该像素足够明亮 if (pixelScore &gt;= 80) &#123; score++ coord = calcCoord(i) motionBox = calcMotionBox(montionBox, coord.x, coord.y) &#125; &#125; return &#123; score, motionBox &#125;&#125;// 得到左上角和右下角两个坐标值function calcMotionBox (curMotionBox, x, y) &#123; const motionBox = curMotionBox || &#123; x: &#123; min: coord.x, max: x &#125;, y: &#123; min: coord.y, max: y &#125; &#125; motionBox.x.min = Math.min(motionBox.x.min, x) motionBox.x.max = Math.max(motionBox.x.max, x) motionBox.y.min = Math.min(motionBox.y.min, y) motionBox.y.max = Math.max(motionBox.y.max, y) return motionBox&#125;// imageData.data 是一个含有每个像素点 rgba 信息的一维数组。// 该函数是将上述一维数组的任意下标转为 (x,y) 二维坐标。function calcCoord(i) &#123; return &#123; x: (i / 4) % diffWidth, y: Math.floor((i / 4) / diffWidth) &#125;&#125; 在得到跟踪矩形的左上角和右下角的坐标值后，通过 ctx.strokeRect(x, y, width, height) API 绘制出矩形即可。 1234567ctx.lineWidth = 6ctx.strokeRect( diff.motionBox.x.min + 0.5, diff.motionBox.y.min + 0.5, diff.motionBox.x.max - diff.motionBox.x.min, diff.motionBox.y.max - diff.motionBox.y.min) 这是理想效果，实际效果请打开 体验链接 扩展：为什么上述绘制矩形的代码中的 x、y 要加 0.5 呢？一图胜千言： 性能缩小尺寸在上一个章节提到，我们需要通过对 Canvas 每个像素进行处理，假设 Canvas 的宽为 640，高为 480，那么就需要遍历 640 * 480 = 307200 个像素。而在监测效果可接受的前提下，我们可以将需要进行像素处理的 Canvas 缩小尺寸，如缩小 10 倍。这样需要遍历的像素数量就降低 100 倍，从而提升性能。 体验地址&gt;&gt; 示例代码：12345678const motionCanvas // 展示给用户看const backgroundCanvas // offscreen canvas 背后处理数据motionCanvas.width = 640motionCanvas.height = 480backgroundCanvas.width = 64backgroundCanvas.height = 48 尺寸缩小 10 倍 定时器我们都知道，当游戏以『每秒60帧』运行时才能保证一定的体验。但对于我们目前的案例来说，帧率并不是我们追求的第一位。因此，每 100 毫秒（具体数值取决于实际情况）取当前帧与前一帧进行比较即可。 另外，因为我们的动作一般具有连贯性，所以可取该连贯动作中幅度最大的（即“分数”最高）或最后一帧动作进行处理即可（如存储到本地或分享到朋友圈）。 延伸至此，用 Web 技术实现简易的“移动监测”效果已基本讲述完毕。由于算法、设备等因素的限制，该效果只能以 2D 画面为基础来判断物体是否发生“移动”。而微软的 Xbox、索尼的 PS、任天堂的 Wii 等游戏设备上的体感游戏则依赖于硬件。以微软的 Kinect 为例，它为开发者提供了可跟踪最多六个完整骨骼和每人 25 个关节等强大功能。利用这些详细的人体参数，我们就能实现各种隔空的『手势操作』，如画圈圈诅咒某人。 下面几个是通过 Web 使用 Kinect 的库： DepthJS：以浏览器插件形式提供数据访问。 Node-Kinect2： 以 Nodejs 搭建服务器端，提供数据比较完整，实例较多。 ZigFu：支持 H5、U3D、Flash，API较为完整。 Kinect-HTML5：Kinect-HTML5 用 C# 搭建服务端，提供色彩数据、深度数据和骨骼数据。 通过 Node-Kinect2 获取骨骼数据 文章至此就真的要结束了，如果你想知道更多玩法，请关注 凹凸实验室。同时，也希望大家发掘更多玩法。 参考资料 使用HTML5开发Kinect体感游戏 MOTION DETECTION WITH JAVASCRIPT","pubDate":"Thu, 29 Jun 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/06/29/motion-detection/","category":"Web开发"},{"title":"流式分页方案探索","link":"https://aotu.io/notes/2017/06/27/infinite-scrolling/","description":"分页类型首先我们要简单认识下，何谓流式分页。分页一般用于对信息列表进行分段。根据具体功能及交互方式的不同，大致可将分页分为两种类型：传统分页和流式分页。 传统分页传统分页多用于 PC 页面，最常见于搜索结果页，如我们常用的搜索引擎 Google： 还有百度： 在京东的搜索结果页中，也可见传统分页的影子： 而在移动端页面中，限制于点击区域的大小，因此较少使用传统分页。 结合上述例子，我们可分析出，传统分页有如下几个特点： 通过页码进行分页 通过点击上/下页按钮可实现页面切换 通过点击页码可实现页面切换 可直接跳转至指定页面 多用于 PC 端 流式分页流式分页在 PC 端和移动端都有使用。PC 页面可用于对多个商品信息的展示，通过滚动的方式加载更多商品信息，如：京东首页还没逛够、发现好货等。而 H5 中，通过点击/上拉的方式来加载列表信息，也是很多见的，如京东首页为您推荐就是使用点击加上拉的方式：腾讯新闻则是通过点击的方式来加载更多信息： 结合上述例子，我们可分析出，流式分页有如下几个特点： 通过滚动/上拉/点击等方式加载新一页 无页码 无上/下页按钮 不可跳转至指定页面 pc端和移动端均有使用 传统分页和流式分页都有各自明显的优缺点，非本文重点，故不展开。有兴趣的同学可前往《Infinite Scrolling vs. Pagination》（Nick Babich 作 / Ruixi 译）查看。 流式分页的实现方案流式分页在前后端都可以实现，需根据实际情况进行决策。下面对前后端的实现及适用场景进行详细介绍。 前端分页的实现在前端分页的实现中，通过接口一次性获取列表的所有内容，根据数据的总长度和每页需展示的个数计算总页数；之后的每次加载操作（滚动/点击）中，依次执行数据截取、DOM 渲染、插入结构的过程，直至最后一页。 前端分页流程图如下： 前文提到的京东首页还没逛够就是采用前端分页的方式。在前后端的配合中，后端为前端提供如下接口：1diviner.jd.com/diviner?p=610009&amp;callback=jsonpCallbackMoreGood&amp;lid=1&amp;lim=100&amp;ec=utf-8 其中相关的参数列表如下： 参数 含义 备注 lim / limit 返回数据个数 由前端根据需要传参，或由后端设置默认值 返回数据如下： 前端将返回的 100 个数据分成两段，依次在需要加载时进行渲染插入操作。 后端根据前端的传参或约定好的数据个数，对数据进行查找。我们使用 Mongo 操作语句（后文提到的后端操作均为 Mongo）来简单表示后端的操作：1Model.find().limit(lim) 前端分页的方法适用于数据较少/分页较少的情况。 后端分页的实现在后端分页的实现中，在加载时，前端通过页码来拉数据，若返回非空数组，则进行 DOM 渲染，插入接口的操作；若返回空数组，则说明当前请求的为最后一页的数据，无需再发送请求。 后端分页流程图如下： 前文提到的发现好货就是采用后端分页的方式。在前后端的配合中，后端为前端提供如下接口：1https://ai.jd.com/index_new.php?app=Discovergoods&amp;action=getDiscZdmGoodsList&amp;callback=listCallback&amp;page=1 其中相关的参数列表如下： 参数 含义 备注 page 当前页数 由前端传参 pageSize / limit 每页数据个数 由前端根据需要传参，或由后端设置默认值 返回数据如下：非空数组： 空数组： 前端记录页数，在加载时根据返回的数据进行渲染插入操作。 后端根据前端对当前页数的传参以及每页数据个数的设置，对数据进行查找： 12const offset = (page-1) * pageSize // 跳过的个数Model.find().skip(offset).limit(pageSize) 后端分页的方法适用于数据较多/分页较多的情况。 后端分页的问题与优化存在的问题1. 数据缺失假设现在需要倒序取 20 条数据，每页展示 10 条。取第 1 页时，客户端通过page=1 pageSize=10传参，获取 20 号-11 号的数据；此时恰好另一客户端删除 17 号数据；取第 2 页时，客户端通过page=2 pageSize=10传参，offset 由原来的 20-11 变成 20-10，导致最后获取 9 号-1 号的数据。最终展示结果为 19 条，10 号数据缺失。具体过程如下： 2. 数据重复假设现在需要倒序取 20 条数据，每页展示 10 条。取第 1 页时，客户端通过page=1 pageSize=10传参，获取 20 号-11 号的数据；此时恰好另一客户端添加 21 号数据；取第 2 页时，客户端通过page=2 pageSize=10传参，offset 由原来的 20-11 变成 21-12，导致最后获取 11 号-2 号的数据。最终展示结果为 20 条，11 号数据重复。具体过程如下： 优化方案1. 使用缓存后端查询数据时，不直接对数据库进行操作，而是查找缓存的数据。缓存的方法有很多，这里介绍一种“按时间分片式缓存”的方法。前端请求数据时，除了前面提到的page和pageSize参数外，还要再传入一个timestamp参数： 请求第 1 页数据时，timestamp 传 0，服务端检查将当前系统时间赋值给 timestamp 返回 请求第 2，3，…n 页数据时，将第 1 步系统返回的 timestamp 传入 其中相关的参数列表如下： 参数 含义 备注 page 当前页数 由前端传参 pageSize 每页数据个数 由前端根据需要传参，或由后端设置默认值 timestamp 时间戳 由前端传参 后端处理时，对传入的timestamp进行判断： 若timestamp为 0，生成当前时间对应的缓存，如“data_1498705088000”，并返回前端所需数据 若timestamp不为 0 且对应的缓存不存在，返回“刷新数据”的提示 若timestamp不为 0 且有对应的缓存，则返回前端所需数据 具体过程如下：（图片来源：《浅谈APP流式分页服务端设计》） 2. 游标式分页 客户端记录当前分页的最后一条数据的 ID 请求下一页的时候，从这个 ID 开始获取一页大小的内容 其中相关的参数列表如下： 参数 含义 备注 curcor 最后一个 ID 由前端传参 pageSize 每页数据个数 由前端根据需要传参，或由后端设置默认值 后端根据前端对最后一个 ID 的传参以及每页数据个数的设置，对数据进行查找：1Model.find(&#123;id: &#123;$gt: cursor&#125;&#125;).limit(pageSize) 优点： 能够避免数据重复/遗漏 无需计算offset，性能更稳定 缺点： 只适用于按照时间追加的方式的简单排序 3. 一次性下发 ID 请求第 1 页数据之前/时先缓存所有 ID 列表 请求第 2，3，…n 页数据时，只需传入相关的 ID 列表参数 如前文提到的腾讯新闻的例子，第一次请求时（除首屏直出数据），请求所有数据的 ID 和第 1 页的数据，接口如下：1http://xw.qq.com/service/api/proxy?key=Xw@2017Mmd&amp;charset=GBK&amp;url=http://openapi.inews.qq.com/getQQNewsIndexAndItems?chlid=news_news_top&amp;refer=mobilewwwqqcom&amp;otype=jsonp&amp;t=1498706343475 返回数据如下： 之后的请求数据，将所需的 ID 列表传入，获取对应的详细信息，接口如下：1http://xw.qq.com/service/api/proxy?key=Xw@2017Mmd&amp;charset=GBK&amp;url=http://openapi.inews.qq.com/getQQNewsNormalContent?ids=20170604A063AG00,20170604A05SKQ00,20170604A05PBT00,NEW2017060403772906,NEW2017060403765707,NEW2017060403278705,20170604A06CMP00,20170604A03ZEU00,20170604A04P5900,NEW2017060402106202,20170603A07E0700,20170604A04WBM00,NEW2017060403031208,20170604A02X9900,20170604A03U6600,20170604A040JX00,20170604A04TE200,NEW2017060403727300,NEW2017060403727800,20170604A03I8200&amp;refer=mobilewwwqqcom&amp;otype=jsonp&amp;t=1496603487427 返回数据如下： 适用于 id 列表不会很大（数百条数据）的业务场景 4. 客户端排除 在客户端中保存已加载记录的 ID 每次请求完数据时，先进行数据去重 若去重数据较多，则考虑再请求下一页的数据 优点： 确保不会出现重复的数据 不改动服务器端的原有逻辑 缺点： 只适用于列表数据添加不是很频繁的情况 参考文档 《浅谈APP流式分页服务端设计》 《浅谈单页应用中前端分页的实现方案》 《APP后端分页设计》 《Infinite Scrolling vs. Pagination》 《瀑布流下拉加载更多导致数据重复怎么办》","pubDate":"Tue, 27 Jun 2017 13:00:00 GMT","guid":"https://aotu.io/notes/2017/06/27/infinite-scrolling/","category":"Web开发"},{"title":"URL编码的奥秘","link":"https://aotu.io/notes/2017/06/15/The-mystery-of-URL-encoding/","description":"URL编码的世界很精彩，你不过来看一下么？","pubDate":"Thu, 15 Jun 2017 02:41:24 GMT","guid":"https://aotu.io/notes/2017/06/15/The-mystery-of-URL-encoding/","category":"Web开发"},{"title":"10个你可能不知道的前端PS技巧","link":"https://aotu.io/notes/2017/06/09/ps-tricks/","description":"PS是各位前端开发者的基础技能，高效利用PS不仅能提高工作效率，更能带来身心上的愉悦——Jack Ma 在前端切图工作里，本质来说就是“选择图层-获取信息、编辑图层-导出图层”的过程，本文主要介绍在这个过程里的一些技巧。 1、面板这里的面板指的是在顶部主菜单“窗口”下可开启的窗口。最常用的几个窗口必属“属性”、“信息”、“图层”，屏幕够大的同学建议把它们都展开在界面右边。那为什么说这几个面板很常用呢？下面会慢慢介绍到。 2、选择图层在移动工具(V)下这个操作非常常用：option+右键/command+左键(windows:alt+右键)，在psd里快速选定图层，点哪选哪。不需要勾选“自动选择”图层选项也能快速选择图层。 而笔者比较喜欢用“option+右键”而不是“command+左键”，因为这个操作经常需要结合视图缩放(option+滚轮，windows:alt+滚轮)，这样来回切换会更方便。 3、属性面板结合快速选择图层，属性面板可以展示不少图层信息，而这些信息在开发中非常有用： 可查看文本的字体大小和颜色等 可查看形状工具(U)画出的形状的填充色和圆角等信息 可查看智能对象的宽高 可以看出属性面板主要展示的是PS比较“原生”的对象的信息。 4、信息面板“信息面板”和“属性面板”类似，只不过前者展现的信息和后者不太一样。 比如，快速选中图层后，如果在“属性面板”不能看到图层的宽高信息，可以command+T(windows:ctrl+T)打开变形操作，在“信息”面板一定可以看到图层的宽高信息，看完后记得按esc顺手退出变形工具以免不小心误操作。 妈妈再也不用担心我矩形选框工具(M)取大概估算元素的宽高值啦…… 5、吸管工具(I)这个工具最基本的功能是吸取图层颜色，这里有几个技巧可以说一下： 左键点击吸取，颜色会实时展示在“信息面板上”； 设计稿经常会看到一些不太明显的渐变色背景色的模块，怎么才能快速知道这是属于渐变色还是纯色的块？按住左键拖动吸管，颜色信息展示在“信息面板”上，通过观察即可知道到底要用background-color还是linear-gradient； 右键需要获取的颜色点，然后会出现菜单，最后一项是“拷贝颜色的十六进制代码”，这里可以快速拷贝色值供css代码用； 如果图层有不透明度，请记得先把不透明度恢复到100%才可以吸取，否则色值会不正确，右键拷贝的色值也会不对； 按住shift键然后吸取，这样会吸取多个色值，并且依次记录在“信息面板”上，这个用于对比色值很有用，在图上相应位置也会标识出顺序，如下图： 6、获取margin的另一种方式在移动工具下(V)，选中图层后，长按command(windows:长按ctrl)键，然后移动鼠标，此时鼠标停留处的图层会出现与选中图层之间的一些紫色标注的一些距离信息，这个用于获取margin比较有用。 7、复制css在图层面板，右键图层，有个“复制css”选项。这个功能在PS里很早就加进来了，可能很多同学都觉得挺鸡肋的，觉得这是给设计师学习css用的。但是其实里面的有一些信息还是挺有用的，可减少一些工作量，比如下面一段css： 123456789101112131415161718192021222324.圆角矩形_584 &#123; border-radius: 15px; background-color: rgb(0, 0, 0); opacity: 0.302; box-shadow: 6px 10.392px 121.83px 9.17px rgba(79, 48, 193, 0.004); position: absolute; left: 283px; top: 306px; width: 136px; height: 32px; z-index: 34;&#125;.矩形_1 &#123; background-image: -moz-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); background-image: -webkit-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); background-image: -ms-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); position: absolute; left: 348px; top: 572px; width: 113px; height: 78px; z-index: 25;&#125; 我们可以用到里面的圆角、背景色、透明度、阴影、宽高、渐变信息，不过说实话代码写法真的挺丑的，比如渐变那个，要进行一些人工的干预处理。不过总归可以少输入一点代码减少工作量，有些信息也不用麻烦各种手段去取、去猜…… 一般来说只是形状工具(U)画出来的形状才会有比较有用的信息，如果是图片类的图层拷贝出来的信息一般只有宽高信息可以用。 8、复制图层到新文件编辑经常会遇到一些设计稿特别大、而我们又不得不进行一些编辑的情况，很容易会出现下面的情况： 所以，从现在起你就应该这样做： 选中图层(组) 图层面板右键图层，选择“复制图层” 在弹出的面板的文档单选框里选择“新建”，如下图 接下来就可以看到在新文件里放置了该图层，然后就可以放心的进行“裁剪、变形、合并图层”等操作了……真的一点都不卡。 9、资源生成器这个功能在最新的几个版本PS里都得到支持，用于切图非常方便。具体操作方法： 首先打开设置，在“增效工具”下，勾选“启用生成器”；然后在主菜单的“文件”-“生成”，勾选“图像资源” 在图层面板选择要导出的图层，把文件名改为如“icon.png”带图片扩展名的图层名，然后就完成了资源生成的全部步骤，就这么简单。生成的资源在文件同目录下、以“-assets”结尾的文件夹里。 图层名可以怎么设置呢？下面列出了一些例子。 图层名 导出图片 logo.png 生成png-32，含透明通道 logo.png8 生成png-8 logo.png24 生成png-24，不含透明通道 img/logo.png24 资源保存在img下 logo.jpg 质量90% logo.jpg8 质量80% logo.jpg5、logo.jpg50% 质量50% 50% logo@1x.png 宽高为原图的50% 50% logo@1x.png + 100% logo@2x.png 用“+”或“,”分割可生成多份资源 图片格式还可以是gif、svg甚至webp等。可以看出资源生成器非常强大，甚至图层编辑后也会同步更新到导出的资源里。要注意图层名要唯一，否则资源会被覆盖。 以上只是一部分配置，有兴趣的同学可以参考文后资料看详细的语法。 10、微调导出的icon网页用rem单位的同学都应该知道，如果png的icon的宽高四周没有空出1像素的透明空白，网页上的icon效果四周很可能会被“吃掉”一点点。所以在icon四周留出1像素的空白很必要。“资源生成器”不能提供这种设置，但是有以下方法可以做到： 图层面板，选中图层(可按shift选多个图层，批量处理相似图层)，右键，选择“导出为” 在弹出面板可设置画布大小，宽高可设置比原来的尺寸大2像素即可，2像素会分配到上下左右各1像素。如下图： 参考资料资源生成器语法 https://helpx.adobe.com/photoshop/using/generate-assets-layers.html#specify-quality-and-size-parameters","pubDate":"Fri, 09 Jun 2017 08:30:00 GMT","guid":"https://aotu.io/notes/2017/06/09/ps-tricks/","category":"资源合集"},{"title":"canvas 图像旋转与翻转姿势解锁","link":"https://aotu.io/notes/2017/05/25/canvas-img-rotate-and-flip/","description":"多图预警，数学不好可直接跳至文末小结。 需求背景从一个游戏需求说起： 技术选型：canvas上图所展示的游戏场景，“可乐瓶”里有多个“气泡”，需要设置不同的动画效果，且涉及 deviceOrientation 的交互，需要有大量计算改变元素状态。从性能方面考虑，canvas 是不二的选择。 技术点：canvas 绘制图像通过对游戏场景的进一步分析，可见场景中的“气泡”元素形状都是相同的，且不规则，通过 canvas 直接绘制形状实现成本较高，因此需要在 canvas 上绘制图像。 技术点：canvas 图像旋转与翻转虽然“气泡”元素是相同的，可以使用相同的图像，但图像需要多个角度/多个方向展示，因此需要对图像进行相应的旋转与翻转（镜像），这也是本文所要介绍的重点。 后文代码以下图左侧绿框的“气泡”为示例，右侧展示了场景中用到的两个图像： 认识 canvas 坐标系canvas 上图像的旋转和翻转，常见的做法是将 canvas 坐标系统进行变换。因此，我们需要先认识 canvas 坐标系统：由上图可得，canvas 2D 环境中坐标系统和 Web 的坐标系统是一致的，有以下几个特点： 坐标原点 (0,0) 在左上角 X坐标向右方增长 Y坐标向下方延伸 回到上述需求中，我们获取 canvas 对象并设置相应的宽高：1&lt;canvas id='myCanvas'&gt;&lt;/canvas&gt; 123456// 获取 canvas 对象var canvas = document.getElementById('myCanvas')canvas.width = 750canvas.height = 1054// 获取 canvas 2D 上下文对象var ctx = canvas.getContext('2d') 此时，canvas 的坐标系统如下图所示： 在 canvas 上绘制图像在 canvas 上绘制图像，可以使用 drawImage() 方法，语法如下（详细用法参见 MDN）：123void ctx.drawImage(image, dx, dy);void ctx.drawImage(image, dx, dy, dWidth, dHeight);void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); 需要注意的是，图像必须加载完毕，才能绘制到 canvas 上，否则会出现空白：123456var img = new Image()img.src = 'xxxxxxx.png'img.onload = function() &#123; // 绘制图像 ctx.drawImage(img, 512, 220, 160, 192);&#125; 此时，便可以 canvas 上看到一个未旋转/翻转的“气泡”图像，如下图所示： canvas 坐标变换接下来，我们再来了解 canvas 坐标的变换。上述需求仅涉及 2D 绘制上下文，因此仅介绍 2D 绘制上下文支持的各种变换： 平移 translate： 1ctx.translate(x, y) translate() 方法接受两个参数。x 是左右偏移量，y 是上下偏移量。 旋转 rotate： 1ctx.rotate(angle) rotate() 方法只接受一个参数。旋转的角度 angle，它是顺时针方向的，以弧度为单位的值。 缩放 scale： 1ctx.scale(x, y) scale() 方法接受两个参数。x 和 y 分别是横轴和纵轴的缩放因子。其缩放因子默认是 1，如果比 1 小是缩小，如果比 1 大则放大。 变形 transform： 1ctx.transform (a, b, c, d, e, f) transform() 方法是对当前坐标系进行矩阵变换。 1ctx.setTransform (a, b, c, d, e, f) setTransform() 方法重置变形矩阵。先将当前的矩阵重置为单位矩阵（即默认的坐标系），再用相同的参数调用 transform() 方法设置矩阵。 以上两个方法均接受六个参数，具体如下： 参数 含义 a 水平缩放绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 图像旋转的实现上图所示“气泡”，宽为 160，高为 192，x 轴方向距离原点 512，y 轴方向距离原点 220，逆时针旋转 35 度。要绘制该“气泡”，需要先将坐标系平移（translate），再旋转（rotate）。具体实现步骤如下： save() 方法与 restore() 方法： save() 方法用来保存 Canvas 状态的，没有参数。每一次调用 save() 方法，当前的状态就会被推入栈中保存起来。当前状态包括： 当前应用的变形（移动/旋转/缩放） strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值 当前的裁切路径（clipping path） restore() 方法用来恢复 Canvas 状态，没有参数。每一次调用 restore() 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。 状态保存在栈中，可以嵌套使用 save() 与 restore()。 图像翻转的实现上图所示“气泡”，宽为 160，高为 192，x 轴方向距离原点 172，y 轴方向距离原点 365，顺时针旋转 35 度。要绘制该“气泡”，需要先将坐标系统平移（translate），翻转（scale），平移（translate），再旋转（rotate）。具体实现步骤如下：至此，实现了“气泡”的镜像翻转，但翻转后的“气泡”还需要旋转特定的角度，在方法一的基础上继续对坐标系统进行变换：以上操作中进行了两次平移（translate）操作，可以进行合并简化： 坐标系统的矩阵变换前文介绍了 2D 绘制上下文变形（transform）变换，实际是直接修改变换的矩阵，它可以实现前面介绍的平移（translate）／旋转（rotate）／缩放（ scale）变换，还可以实现切变/镜像反射变换等。矩阵计算遵循数学矩阵公式规则：由上公式可得：12x' = ax + cy + ey' = bx + dy + f 矩阵变换可实现以下变换效果： 平移 translate： 12x' = 1x+0y+tx = x+txy' = 0x+1y+ty = y+ty 旋转 rotate： 12x' = x*cosθ-y*sinθ+0 = x*cosθ-y*sinθy' = x*sinθ+y*cosθ+0 = x*sinθ+y*cosθ 缩放 scale： 12x' = Sx*x+0y+0 = Sx*xy' = 0x+Sy*y+0 = Sy*y 切变 12x' = x+y*tan(θx)+0 = x+y*tan(θx)y' = x*tan(θy)+y+0 = x*tan(θy)+y 镜像反射 12345// 定义(ux,uy)为直线(y=kx)方向的单位向量ux=1/sqrt(1+k^2)uy=k/sqrt(1+k^2)x' = (2*ux^2-1)*x+2*ux*uy*yy' = 2*ux*uy*x+(2*uy^2-1)*y 结合上述公式，可推导出图像旋转和翻转的矩阵变换实现： 图像旋转： 图像翻转： 图像镜像反射（翻转+旋转）： 像素操作实现图像翻转除了坐标系统变换，canvas 的像素操作同样可以实现图像的翻转。首先需要了解下 getImageData() 方法（详细用法参见MDN）和 putImageData()（详细用法参见MDN）方法： getImageData()CanvasRenderingContext2D.getImageData() 返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为 (sx, sy)、宽为 sw、高为 sh。 1ImageData ctx.getImageData(sx, sy, sw, sh); putImageData()CanvasRenderingContext2D.putImageData() 是 Canvas 2D API 将数据从已有的 ImageData 对象绘制到位图的方法。 如果提供了脏矩形，只能绘制矩形的像素。 12void ctx.putImageData(imagedata, dx, dy);void ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight); 水平翻转实现：12345678910111213141516171819202122// 绘制图像ctx.drawImage(img, x, y, width, height)// 获取 img_data 数据var img_data = ctx.getImageData(x, y, width, height), i, i2, t, h = img_data.height, w = img_data.width, w_2 = w / 2;// 将 img_data 的数据水平翻转for (var dy = 0; dy &lt; h; dy ++) &#123; for (var dx = 0; dx &lt; w_2; dx ++) &#123; i = (dy &lt;&lt; 2) * w + (dx &lt;&lt; 2) i2 = ((dy + 1) &lt;&lt; 2) * w - ((dx + 1) &lt;&lt; 2) for (var p = 0; p &lt; 4; p ++) &#123; t = img_data.data[i + p] img_data.data[i + p] = img_data.data[i2 + p] img_data.data[i2 + p] = t &#125; &#125;&#125;// 重绘水平翻转后的图片ctx.putImageData(img_data, x, y) 小结至此，小编的数学姿势又恢复到了高考水平。 图像旋转： 基础变换法： 12345ctx.save()ctx.translate(x + width / 2, y + height / 2)ctx.rotate(angle * Math.PI / 180)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 矩阵变换法： 12345ctx.save()var rad = angle * Math.PI/180ctx.transform( Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), x + width / 2, y + height / 2)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 图像翻转： 基础变换法： 123456// 方法一ctx.save()ctx.translate(canvasWidth, 0)ctx.scale(-1, 1)ctx.drawImage(img, canvasWidth-width-x, y, width, height)ctx.restore() 12345// 方法二ctx.save()ctx.scale(-1, 1)ctx.drawImage(img, -width-x, y, width, height)ctx.restore() 矩阵变换法： 12345// 方法一ctx.save()ctx.transform(-1, 0, 0, 1, canvasWidth, 0)ctx.drawImage(img, canvasWidth-width-x, y, width, height)ctx.restore() 12345// 方法二ctx.save()ctx.transform(-1, 0, 0, 1, 0, 0)ctx.drawImage(img, -width-x, y, width, height)ctx.restore() 像素操作法： 123456789101112131415161718ctx.drawImage(img, x, y, width, height)var img_data = ctx.getImageData(x, y, width, height), i, i2, t, h = img_data.height, w = img_data.width, w_2 = w / 2;for (var dy = 0; dy &lt; h; dy ++) &#123; for (var dx = 0; dx &lt; w_2; dx ++) &#123; i = (dy &lt;&lt; 2) * w + (dx &lt;&lt; 2) i2 = ((dy + 1) &lt;&lt; 2) * w - ((dx + 1) &lt;&lt; 2) for (var p = 0; p &lt; 4; p ++) &#123; t = img_data.data[i + p] img_data.data[i + p] = img_data.data[i2 + p] img_data.data[i2 + p] = t &#125; &#125;&#125;ctx.putImageData(img_data, x, y) 图像镜像对称（翻转+旋转）： 基础变换法： 123456ctx.save()ctx.scale(-1, 1)ctx.translate(-width/2-x, y+height/2) ctx.rotate(-angle * Math.PI / 180)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 矩阵变换法： 1234567ctx.save()var k = Math.tan( (180-angle)/2 * Math.PI / 180 )var ux = 1 / Math.sqrt(1 + k * k)var uy = k / Math.sqrt(1 + k * k)ctx.transform( (2*ux*ux-1), 2*ux*uy, 2*ux*uy, (2*uy*uy-1), x + width/2, y + height/2 )ctx.drawImage(img, -width/2, -height/2, width, height)ctx.restore() 参考文章 《W3cplus - CANVAS 系列》 《html5 canvas.transform[转]》 《html5 canvas 学习笔记》 《在HTML5中翻转图片》 说明：本文讨论的 canvas 环境均为 2D 环境。若有更好的实现方式，欢迎留言告知。","pubDate":"Thu, 25 May 2017 15:00:00 GMT","guid":"https://aotu.io/notes/2017/05/25/canvas-img-rotate-and-flip/","category":"Web开发"},{"title":"一个例子上手SVG动画","link":"https://aotu.io/notes/2017/05/04/example-for-svg-animation/","description":"CSS3动画已足够强大，不过还是有一些它做不到的地方。配合SVG，让Web动效有更多的可能性。这次要做的效果是一个loading动画（如图）：其中旋转通过CSS来完成，但是旋转之后圆弧缩短变成笑脸的嘴巴需要借助SVG来实现。 Step1、声明SVG视口1&lt;svg width=\"100\" height=“100”&gt;&lt;/svg&gt; 指定一个宽高都为100像素的区域，width=”100”和width=”100px”是等价的，当然也可以使用其他的合法单位，例如cm、mm、em等。阅读器会设置一个默认的坐标系统，见图：左上角为原点，其中水平（x）坐标向右递增，垂直（y）坐标向下递增。 在没有指定的情况下，所有的的数值默认单位都是像素。 Step2、绘制购物袋购物袋由两个部分组成，先画下面的主体： 1&lt;path d=\"M 20 40 L 80 40 L 80 90 A 10 10 90 0 1 70 100 L 30 100 A 10 10 90 0 1 20 90\" style=\"fill: #e9e8ee;\" /&gt; 任何形状都可以使用路径元素画出，描述轮廓的数据放在它的d属性中。a.样式中的fill用来设置填充色。b.路径数据由命令和坐标构成: 指令 说明 M 20 40 表示移动画笔到(20,40) L 80 40 表示绘制一条线到(80, 40) A 10 10 90 0 1 70 100 绘制一个椭圆弧 圆弧命令以字母A开始，后面紧跟着7个参数，这7个参数分别用来表示： 椭圆的x半径和y半径 椭圆的x轴旋转角度 圆弧的角度小于180度，为0；大于或等于180度，则为1 以负角度绘制为0，否则为1 终点的x、y坐标 接下来绘制购物袋上面的部分 1&lt;path d=\"M 35 40 A 15 15 180 1 1 65 40\" style=\"fill: none; stroke: #e9e8ee; stroke-width: 5;” /&gt; 上面的部分是一个半圆弧，我同样用路径来画出，也可以使用基础形状来完成。样式中的stoke和stroke-width分别用来设置描边色和描边的宽度。 Step3、绘制眼睛12&lt;circle cx=“40\" cy=\"60\" r=\"2.5\" style=\"fill: #fff;\" /&gt;&lt;circle cx=\"60\" cy=\"60\" r=\"2.5\" style=\"fill: #fff;\" /&gt; 使用基础形状，画两个个小圆点。四个属性分别是位置坐标、半径和填充颜色。 Step4、绘制嘴巴1&lt;circle cx=\"50\" cy=\"70\" r=\"15\" style=\"fill: none; stroke: #fff; stroke-width: 5; stroke-linecap: round;transform: rotate(280deg); transform-origin: 50% 50%; stroke-dashoffset: -23; stroke-dasharray: 42, 95;”&gt; 嘴巴是一段圆弧，我绘制了一个圆，然后描边了其中的一段，并且做了一个旋转，来让它的角度处于正确的位置。 stroke-linecap：用来定义开放路径的终结,可选round|butt|square stroke-dasharray：用来创建虚线 stroke-dashoffset：设置虚线位置的起始偏移值，在下一步骤里，它会和stroke-dasharray一起用来实现动效。 Step5、给嘴巴部分添加动效1234567891011121314151617@keyframes mouth &#123; 0% &#123; transform: rotate(-80deg); stroke-dasharray: 60, 95; stroke-dashoffset: 0; &#125; 40% &#123; transform: rotate(280deg); stroke-dasharray: 60, 95; stroke-dashoffset: 0; &#125; 70%, 100% &#123; transform: rotate(280deg); stroke-dashoffset: -23; stroke-dasharray: 42, 95; &#125;&#125; 动画分为两个部分： 圆弧旋转 旋转之后缩短变形 在一个循环里，最后留有30%的时间保持一个停留。 Step6、给眼睛添加动画两只眼睛都是沿着圆弧运动 ，例如左眼，首先用一个路径来规定它的运动轨迹：1&lt;path id=\"eyeright\" d=\"M 40 60 A 15 15 180 0 1 60 60\" style=\"fill: none; stroke-width: 0;\" /&gt; 然后使用animateMotion来设置动画：12345678910&lt;circle class=\"eye\" cx=\"\" cy=\"\" r=\"2.5\" style=\"fill: #fff;\"&gt; &lt;animateMotion dur=\"0.8s\" repeatCount=\"indefinite\" keyPoints=\"0;0;1;1\" keyTimes=\"0;0.3;0.9;1\" calcMode=\"linear\"&gt; &lt;mpath xlink:href=\"#eyeleft\"/&gt; &lt;/animateMotion&gt;&lt;/circle&gt; dur：动画的时间 repeatCount：重复次数 keyPoints：运动路径的关键点 timePoints：时间的关键点 calcMode：控制动画的运动速率的变化，discrete | linear | paced | spline四个属性可选 mpath：指定一个外部定义的路径 Step7、将不同部位的动画组合到一起 眼睛的动画是从嘴巴旋转完成开始，到嘴巴变形完成结束，因此和嘴巴的动画一样，我设置了四个对应的关键时间点。 为了让衔接更顺畅，眼睛的动画开始比嘴巴变形开始稍微提前了一点点。 参考： MDN-SVG文档 《SVG精髓》- 人民邮电出版社","pubDate":"Thu, 04 May 2017 11:21:03 GMT","guid":"https://aotu.io/notes/2017/05/04/example-for-svg-animation/","category":"Web开发"},{"title":"利用视口单位实现适配布局","link":"https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/","description":"响应式布局的实现依靠媒体查询（ Media Queries ）来实现，选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配。即使是通过 rem 单位来实现适配，也是需要内嵌一段脚本去动态计算根元素大小。 近年来，随着移动端对视口单位的支持越来越成熟、广泛，使得我们可以尝试一种新的办法去真正地适配所有设备尺寸。 认识视口单位（ Viewport units )首先，我们要了解什么是视口。 在业界，极为推崇的一种理论是 Peter-Paul Koch (江湖人称“PPK大神”)提出的关于视口的解释——在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。 而视口单位中的“视口”，在桌面端，毫无疑问指的就是浏览器的可视区域；但是在移动端，它指的则是三个 Viewport 中的 Layout Viewport 。 视口单位中的“视口” 根据CSS3规范，视口单位主要包括以下4个： vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个 视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。 用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况） 例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。 兼容性其兼容性如下图所示，可以知道：在移动端 iOS 8 以上以及 Android 4.4 以上获得支持，并且在微信 x5 内核中也得到完美的全面支持。 截图来自Can I Use 截图来自X5内核－Can I Use 利用视口单位适配页面对于移动端开发来说，最为重要的一点是如何适配页面，实现多终端的兼容，不同的适配方式各有千秋，也各有缺点。 就主流的响应式布局、弹性布局来说，通过 Media Queries 实现的布局需要配置多个响应断点，而且带来的体验也对用户十分的不友好：布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。 而通过采用rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。 有没有办法能够解决这样的问题呢？ 答案是肯定的，通过利用视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的。 做法一：仅使用vw作为CSS单位在仅使用 vw 单位作为唯一应用的一种 CSS 单位的这种做法下，我们遵守： 1.对于设计稿的尺寸转换为vw单位，我们使用Sass函数编译 12345//iPhone 6尺寸作为设计稿基准$vm_base: 375; @function vw($px) &#123; @return ($px / 375) * 100vw;&#125; 2.无论是文本还是布局高宽、间距等都使用 vw 作为 CSS 单位 1234567891011121314151617181920212223242526.mod_nav &#123; background-color: #fff; &amp;_list &#123; display: flex; padding: vm(15) vm(10) vm(10); // 内间距 &amp;_item &#123; flex: 1; text-align: center; font-size: vm(10); // 字体大小 &amp;_logo &#123; display: block; margin: 0 auto; width: vm(40); // 宽度 height: vm(40); // 高度 img &#123; display: block; margin: 0 auto; max-width: 100%; &#125; &#125; &amp;_name &#123; margin-top: vm(2); &#125; &#125; &#125;&#125; 3.1物理像素线（也就是普通屏幕下 1px ，高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现。 1234567891011121314151617181920.mod_grid &#123; position: relative; &amp;::after &#123; // 实现1物理像素的下边框线 content: ''; position: absolute; z-index: 1; pointer-events: none; background-color: #ddd; height: 1px; left: 0; right: 0; top: 0; @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123; -webkit-transform: scaleY(0.5); -webkit-transform-origin: 50% 0%; &#125; &#125; ...&#125; 4.对于需要保持高宽比的图，应改用 padding-top 实现 12345678910111213.mod_banner &#123; position: relative; padding-top: percentage(100/700); // 使用padding-top height: 0; overflow: hidden; img &#123; width: 100%; height: auto; position: absolute; left: 0; top: 0; &#125;&#125; 由此，我们能够实现一个常见布局的页面效果如下： 体验地址点击此处 做法二：搭配vw和rem，布局更优化这样的页面虽然看起来适配得很好，但是你会发现由于它是利用视口单位实现的布局，依赖于视口大小而自动缩放，无论视口过大还是过小，它也随着视口过大或者过小，失去了最大最小宽度的限制。 当然，你可以不在乎这样微小的不友好用户体验，但我们还是尝试下追求修复这样的小瑕疵吧。 于是，联想到不如结合rem单位来实现布局？rem 弹性布局的核心在于动态改变根元素大小，那么我们可以通过： 给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度 这样我们就能够实现对布局宽度的最大最小限制。因此，根据以上条件，我们可以得出代码实现如下： 123456789101112131415161718192021222324// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值@function rem($px) &#123; @return ($px / $vm_fontsize ) * 1rem;&#125;// 根元素大小使用 vw 单位$vm_design: 750;html &#123; font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125; 这里就不再给出截图，但你可以点击此处在线地址进行体验。 小结相对于做法一，个人比较推崇做法二，有以下两点原因： 第一，做法二相对来说用户视觉体验更好，增加了最大最小宽度的限制； 第二，更重要是，如果选择主流的rem弹性布局方式作为项目开发的适配页面方法，那么做法二更适合于后期项目从 rem 单位过渡到 vw 单位。只需要通过改变根元素大小的计算方式，你就可以不需要其他任何的处理，就无缝过渡到另一种CSS单位，更何况vw单位的使用必然会成为一种更好适配方式，目前它只是碍于兼容性的支持而得不到广泛的应用。 后语这是笔者在偶然中阅读到[翻译]使用VH和VW实现真正的流体排版这一篇文章得到的感悟与成果，也满心欢喜地期待这篇文章同样能够带给读者一些启发，并提出一些的vw单位使用秘笈来交流交流～:） 参考文档 基于视口单位的网页排版 (转）基于视口单位的网页排版 [翻译]使用VH和VW实现真正的流体排版","pubDate":"Fri, 28 Apr 2017 02:25:00 GMT","guid":"https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/","category":"Web开发"},{"title":"【译】关于 Node.js 里 ES6 Modules 的一次更新说明","link":"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/","description":"James M Snell IBM Technical Lead for Node.js原文链接: An Update on ES6 Modules in Node.js 几个月前，我写了一篇文章来描述 Node.js 现存的 CommonJS 模块和新的 ES6 模块系统的许多不同，也说明了在 Node.js 内核中实现这个新模型的内在的一些挑战。现在，我想分享一下关于这件事情的进展情况。 明白你什么时候该知道你需要知道的东西在这之前，如果你还没准备好，你可以花一点时间来看一下我之前的描述这两个模块架构上存在许多根本区别的文章。总结来说就是：CommonJS 与 ES6 Modules 之间的关键不同在于代码什么时候知道一个模块的结构和使用它。 举个栗子，假如我现在有一个简单的 CommonJS 模块（模块名叫&#39;foobar&#39;）： 12345678function foo() &#123; return 'bar';&#125;function bar() &#123; return 'foo';&#125;module.exports.foo = foo;module.exports.bar = bar; 现在我们在一个叫 app.js 的 JS 文件中引用它 12const &#123;foo, bar&#125; = require('foobar');console.log(foo(), bar()); 当我执行 $node app.js 的时候，Node.js 已二进制的形式加载 app.js 文件，解析它，并且开始执行里面的代码。在执行过程中，里面的 require() 方法被调用，然后它会同步的去加载 foobar.js 的内容进内存，同步的解析编译里面的 JavaScript 代码，同步的执行里面的代码，然后返回 module.exports 的值当做 app.js 里的 require(&#39;foobar&#39;) 的返回值。当 app.js 里的 require() 方法返回的时候，foobar 模块的结构就已经知道了，并且可以被使用。所有的这些事情都发生在 Node.js 进程事件循环的同一个周期里。 要理解 CommonJS 与 ES6 Modules 之间的不同至关重要的是，一个 CommonJS 的模块在没有被执行完之前，它的结构（API）是不可知的 — 即使在它被执行完以后，它的结构也可以随时被其他代码修改。 现在我们用 ES6 的写法来写同样的模块： 123456export function foo() &#123; return 'bar';&#125;export function bar() &#123; return 'foo';&#125; 并且在代码中引用它： 123import &#123;foo, bar&#125; from 'foobar';console.log(foo());console.log(bar()); 从 ECMAScript 统一的标准来看，ES6 Modules 的步骤与 CommonJS 里已经实现的有很大的不同。第一步从硬盘上加载文件内容大致上是相同的，但是可能是异步的。当内容加载完成后，会解析它。在解析的同时，模块里被 export 声明定义的结构会在组件内容被执行之前就探知出来。一旦结构被探知出来，组件的代码就会被执行。这里重要的是记住所有的 import 和 export 语句都会在代码执行之前被解析出来。另一点是在 ES6 中是允许这个解析的步骤异步执行的。这就意味着，在 Node.js 的机制中，加载脚本内容、解析模块的 import 和 export 、执行模块代码将发生在多个事件循环里。 时机很重要在评估 ES6 Modules 的可实现性之前，我们关注的重点是怎么样无缝衔接的实现它。比如我们希望它可以可以实现同时对两种模块的支持，这样可以很大程度上对用户是透明的。 可惜，事情并不是这么简单… 尤其是 ES6 Modules 的加载、解析和执行都是异步的，这就导致不能通过 require() 来引用一个 ES6 模块。原因是 require() 是一个完全同步的函数。如果我们去修改 require() 的语义让它可以进行异步加载的话，那对于现有的生态系统将会产生巨大的破坏。所以我们有考虑在 ES6 的 import() 函数提议（详情）通过之后建模实现一个 require.import() 函数。这个函数会返回一个 Promise 在 ES6 模块加载完成后标记完成。这不是最好的方案，但是它可以让你在现有的 Node.js 里以 CommonJS 的格式来使用。 有一点好消息是在 ES6 模块里可以很方便地使用 import 来引用一个 CommonJS 模块。因为在 ES6 模块里异步加载不是必须的。ECMAScript 规范进行一些小修改就可以更好地支持这种方式。但是所有这些工作过后，还有一个重要的事情… 命名引用命名引用是 ES6 Modules 里的一个基本的特性。举个例子： 1import &#123;foo, bar&#125; from 'foobar'; 变量 foo 和 bar 在解析阶段就从 foobar 中被引用进来 —— 在所有代码被执行之前。因为 ES6 Modules 的结构是之前就可以被探知到的。 另一方面，在 CommonJS 里模块结构在代码没有执行之前是不能被探知的。也就是说，如果不对 ECMAScript 规范做重大更改的话，在 CommonJS 模块里是不能使用命名引用的。开发者会引用到 ES6 Modules 里面的名为 “default” 的导出。比如，上面的例子在 CommonJS 里是这样的： 12import foobar from 'foobar';console.log(foobar.foo(), foobar.bar()); 区别很小但是很重要。所以当你想使用 import 来引用一个 CommonJS 模块的时候，下面这种写法是根本行不通的： 1import &#123;foo, bar&#125; from 'foobar'; 这里的 foo 和 bar 不会直接被解析成 CommonJS 模块里导出的 foo() 和 bar() 方法。 但是在 Babel 里可以！使用过像 Babel 这种的 ES6 Modules 语法转换工具的人应该很熟悉命名引用。Babel 的工作原理是把 ES6 的写法转换成可以在 Node.js 里运行的 CommonJS 的形式。虽然语法看起来很像 ES6，但是实际上并不是。这一点很重要，Babel 里的 ES6 命名引用与完全按照规范实现的 ES6 命名引用有本质的不同。 Michael Jackson Script实际上CommonJS 和 ES6 Modules 之间还有另外一个重要的不同就是，ECMAScript 编译器必须提前知道它加载的代码是 CommonJS 的还是 ES6 Modules 的。原因是之前说的 ES6 Modules 必须在代码执行前就解析出模块中的 import 和 export 声明。 这就意味着 Node.js 需要某些机制来预先识别它在加载那种类型的文件。在探索了很多方案以后，我们回归到了以前最糟糕的方案，就是引入一个新的 *.mjs 文件后缀来表示一个 ES6 Modules 的 JavaScript 文件。（之前我们亲切的叫它 “Michael Jackson Script”） 时间线在目前的时间点上，在 Node.js 可以开始处理支持实现 ES6 Modules 之前，还有很多关于规范现实的问题和虚拟机方面的问题。相关工作还在进行，但是需要一些时间 —— 我们目前估计至少需要一年左右。","pubDate":"Sat, 22 Apr 2017 02:09:24 GMT","guid":"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/","category":"NodeJS"},{"title":"Matter.js 2D 物理引擎试玩报告","link":"https://aotu.io/notes/2017/04/17/Matter-js/","description":"何为物理引擎，能做什么？物理引擎是一个计算机程序，使用质量、速度、摩擦力和空气阻力等变量，模拟了一个近似真实的物理系统，为刚性物体赋予真实的物理效果，比如重力、旋转和碰撞等效果，让物体的行为表现的更加趋向真实，例如，守望先锋的英雄在跳起时，系统所设置的重力参数就决定了他能跳多高，下落时的速度有多快，子弹的飞行轨迹等等。 四个例子不同的效果，模拟物体落入斜坡的表现 无物理效果 重力，没有碰撞效果 重力和碰撞，没有旋转效果 重力、碰撞以及旋转效果 物理引擎通常有两种常见类型：实时物理引擎和高精度物理引擎。高精度物理引擎需要更多的处理能力来计算非常精确的物理，通常使用在科学研究（计算物理学）和动画电影制作。实时物理引擎常用于电子游戏并且简化了算法，降低精确度以减少处理时间，使得在游戏中有更好的处理速度。 物理引擎在游戏中的应用CS1.5 应用的是真实度比较差的物理引擎，人物死亡后倒地动作是固定的，即使有障碍物也会执行这个动作，所以人物穿过了门。 而 CS:GO 因为采用了 Source Engine 开发，模拟较为精细，所以人物死亡之后的姿势可以根据物理学自动计算，所以可以躺在杆上，使游戏更加真实。 Matter.js 介绍Matter.js 是一个用于 Web 的 JavaScript 2D 物理引擎库，该项目诞生于 2014 年 2 月 28 号（0.5.0-alpha 版本），目前已更新迭代了 11 个版本（最新为 0.12.0 版本），它相较于老牌的 Box2D 引擎库，Matter.js 更为轻量级（压缩版仅有 84 KB），并且在性能和功能方面也不逊色。 在没有 Matter.js 前，你想去制作一个物理游戏不仅需要扎实数学知识和物理知识，并且需要通过编程语言表示出来让机器读懂。而有 Matter.js 就不一样了，它为开发者提供了许多的功能模块，通过简单易用的 API 就可以实现例如弹跳、碰撞、重力、滚动等物理效果。 Matter.js 下载首先，需要下载开发版本或者稳定版定，并将脚本加入到页面中，即可开启旅程。 1&lt;script src=\"matter.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 你也可以使用包管理工具 Bower 或 NPM 1$ bower install matter-js 1$ npm install matter-js Matter.js 支持的特性刚体复合体复合材料凹面和凸面物理特性（质量、面积、密度等）弹性（弹性和非弹性碰撞）碰撞（粗略阶段、中间阶段、精细阶段）稳定的堆叠和静止动量守恒摩擦力和阻力事件监听约束重力睡眠和静态物体圆角（倒角）视图（平移、缩放）碰撞查询（射线追踪、区域测试）时间缩放（减速、加速）Canvas 渲染器（支持向量和纹理）MatterTools 工具（创建、测试和调试）世界状态序列化，需要 resurrect.js跨浏览器（Chrome、Firefox、Safari、IE8+）兼容移动端（触摸、响应）原生 JS 实现 Matter.js 中基础的概念大多数的物理引擎对于物理模拟的要素都有着相近的概念，不同的引擎差别在于使用的方式，功能的全面性，模拟的精细度等层面，下面就先从物理世界的基础概念讲起。 Engine（引擎）和 World（世界）Matter.Engine 模块包含了创建和处理引擎的方法，引擎是负责管理和更新模拟世界的控制器，引擎可以控制时间的缩放，可以检测所有的碰撞事件，并且拿到所有碰撞的物体对（pairs）。 在 Matter.js 中任何的物体都需要一个容身处，而存放这些物体的地方，我们称之为世界，物体必须添加到世界里，然后由引擎运行这个世界。而创建世界需要使用到 Matter.World 模块，该模块包含了用于创建和操作世界的方法，一个 Matter.World 相当于一个复合物体，物体、约束、复合物体的聚合体，其次世界还有额外的一些属性，比如重力、边界。 Render（渲染）1234567891011121314// Matter.Render 用法var engine = Engine.create();// ... 将物体加入到世界中var render = Render.create(&#123; element: document.body, engine: engine, options: options&#125;);Engine.run(engine);Render.run(render); element 是一个容器元素，使用时指定要渲染的节点 engine 指定为 Matter.Engine 实例 options 指定一些渲染的参数 Matter.Render 是将实例渲染到 Canvas 中的渲染器，控制视图层的样式，它的主要作用是用于开发和调试，默认情况下 Matter.Render 将只显示物体的线框（轮廓），这对于开发和调试很有帮助，但如果需要使用到全局实体渲染则需要将线框模式关闭 render.options.wireframes = false，另外它同样也适合制作一些简单的游戏，因为它包括了一些绘图选项、线框、向量、Sprite 精灵和视窗功能。 DEMO 戳这里 Body（刚体）物体或者叫刚体，在物理引擎里特指坚硬的物体，具有固定的形状，不能形变。刚体可以用于表示一个箱子、一个球或是一块木头，每个物体都有自己的物理属性，质量、速度、摩擦力、角度等，还可以设置刚体的标记。Matter.Bodies 模块中内置了几种刚体，矩形 Matter.rectangle、多边形 Matter.polygon、圆形 Matter.circle 、梯形 Matter.trapezoid 等等。 12345678// 创建刚体var rect = Bodies.rectangle(200, 100, 50, 50), // 矩形 circle = Bodies.circle(300, 100, 25), // 圆 polygon = Bodies.polygon(450, 100, 5, 25), // 多边形 trapezoid = Bodies.trapezoid(590, 100, 50, 50, 3); // 梯形// 将刚体添加到世界中World.add(engine.world, [rect, circle, polygon, trapezoid]); DEMO 戳这里 Composite（复合体）由刚体和复合材料通过约束组合在一起的就叫做复合体。复合体对外当作一个刚体，复合体的物理属性是通过所包含的刚体的属性综合计算出来的。Matter.Composite 模块包含用于创建和处理复合体的方法，另外还有一个 Matter.Composites 模块，提供了几种特别的复合材料，例如 链 Composites.chain、牛顿摆球 Composites.newtonsCradle、软体 Composites.softBody、汽车 Composites.car 、堆叠 Composites.stack 等等。 桥梁 12345678910111213// 使用堆叠创建桥梁var group = Body.nextGroup(true);var bridge = Composites.stack(150, 300, 9, 1, 10, 10, function(x, y) &#123; return Bodies.rectangle(x, y, 50, 20, &#123; collisionFilter: &#123; // 过滤碰撞 group: group &#125; &#125;);&#125;);// 创建链约束Composites.chain(bridge, 0.5, 0, -0.5, 0, &#123; stiffness: 0.9 &#125;); DEMO 戳这里 布 12345678910// 软体var cloth = Composites.softBody(200, 200, 20, 12, 5, 5, false, 8, &#123; friction: 0.00001, // 摩擦力 collisionFilter: &#123; group: Body.nextGroup(true) &#125;, render: &#123; visible: false &#125;&#125;); DEMO 戳这里 牛顿摆球 12// 创建牛顿摆球var newtonsCradle = Composites.newtonsCradle(300, 320, 5, 25, 150); DEMO 戳这里 Constraint（约束）约束可理解为通过一条线，将刚体 A 和刚体 B 两个刚体连接起来，被约束的两个刚体由于被连接在了一起，移动就相互受到了限制。Matter.Constraint 模块包含了用于创建和处理约束的方法，这个约束可以很宽松，也可以很紧绷，还可以定义约束的距离，约束具有弹性，可以用来当作橡皮筋。 1234567891011121314151617181920212223// 创建一个矩形和圆形var rect = Bodies.rectangle(400, 100, 50, 50, &#123; isStatic: true &#125;), ball = Bodies.circle(400, 400, 50);World.add(engine.world, [ rect, ball, Constraint.create(&#123; bodyA: rect, // 约束刚体 A pointA : &#123; // 约束点 A x: 0, y: 0 &#125;, bodyB: ball, // 约束刚体 B pointB: &#123; // 约束点 B x: 0, y: -50 &#125;, stiffness: 0.6 &#125;)]); DEMO 戳这里 MouseConstraint（鼠标约束）如果你想让刚体与用户之间有交互，那就要在鼠标和刚体之间建立连接，也就是鼠标和刚体间的约束，Matter.MouseConstraint 模块包含用于创建鼠标约束的方法，提供通过鼠标或触摸（移动端时）移动刚体的能力，可以设置什么标记的物体才能被鼠标操纵，创建鼠标约束后，可以捕获到鼠标的各类事件。 123456// 全局鼠标约束var mouseConstraint = MouseConstraint.create(&#123; element: render.canvas&#125;);World.add(engine.world, mouseConstraint); 12345678910111213141516171819// 设置某个标记的物体才能被鼠标操纵var categoryBall = 0x0001; // 分类var ball = Matter.Bodies.circle(300, 350, 32, &#123; density: 0.68, // 密度 restitution: 1, // 弹性 collisionFilter: &#123; category: categoryBall &#125;&#125;);var mouseConstraint = MouseConstraint.create(&#123; element: render.canvas, collisionFilter: &#123; mask: categoryBall &#125;&#125;);World.add(engine.world, mouseConstraint); DEMO 戳这里 Vector（向量）Matter.Vector 模块包含用于创建和操纵向量的方法，向量是引擎有关几何操作行为的基础，修改物体的运动状态基本都是使用向量来控制，例如赋予物体一个力，或者设置物体的速度、旋转角度，并且内置了多个向量的求解函数：向量积、标量积、格式化、垂直向量等等。 Events（事件）Matter.Events 模块包含了绑定、移除和触发对象的方法。 绑定事件 Matter.Events.on(object, eventNames, callback) 移除事件 Matter.Events.off(object, eventNames, callback) 触发事件 Matter.Events.trigger(object, eventNames, event) Matter.js 中的一些属性施加力Matter.Body.applyForce(body, position, force) 方法可以给刚体施加一个力，传入 X 和 Y 轴需要的力度值，通过这个方法你可以去模拟踢一个足球、投一个篮球的效果。 123456789101112131415161718var ball = Bodies.circle(300, 100, 25, &#123; density: 0.68, // 密度 restitution: 0.8 // 弹性&#125;);World.add(engine.world, ball);function addForce() &#123; var forceMagnitude = 0.02 * ball.mass; Body.applyForce(ball, ball.position, &#123; x : (forceMagnitude + Common.random() * forceMagnitude) * Common.choose([1, -1]), y : -forceMagnitude + Common.random() * -forceMagnitude &#125;);&#125;addForce(); DEMO 戳这里 重力可以设置 X、Y 轴的重力值，默认都为 1，参数在 0、1、-1 中选择使用。 12345// 实现反重力效果engine.world.gravity.y = -1;// 无重力效果engine.world.gravity.y = 0; DEMO 戳这里 睡眠状态通过 enableSleeping: true 开启睡眠模式后，当刚体处于不受作用状态时，会进入睡眠状态，这样可以有效的提高引擎的性能，当物体被其他物体碰撞或者对刚体施加力时，刚体会被叫醒，引擎会继续对其进行计算模拟。 123456789// 开启睡眠状态var engine = Engine.create(&#123; enableSleeping: true&#125;);// 还可以针对进入睡眠状态的刚体进行监听，比如将刚体移出世界Event.on(ball, \"sleepStart\", function() &#123; World.remove(engine.world, ball);&#125;); DEMO 戳这里 摩擦力摩擦力在 Matter.js 中分别提供了三种：摩擦力 friction、空气摩擦力 frictionAir 以及静止摩擦力 frictionStatic。friction 默认值是 0.1，取值范围在 0 - 1，当值为 0 意味着刚体可以摩擦力的无限滑动，1 意味着对刚体施加力后会立刻停止，frictionAir 默认值是 0.01，取值范围 0 - 1，当值为 0 意味着刚体在空间中移动时速度永远不会减慢，值越高时刚体在空间的移动速度越慢，frictionStatic 默认值 0.5，当值为 0 时意味着刚体几乎是静止的，值越高时意味着需要移动刚体所需的力就越大。 1234567891011121314// 摩擦力Bodies.rectangle(300, 70, 40, 40, &#123; friction: 0.01&#125;)// 空气摩擦力Bodies.rectangle(300, 70, 40, 40, &#123; frictionAir: 0.05&#125;)// 静止摩擦力Bodies.rectangle(300, 70, 40, 40, &#123; frictionStatic: 1&#125;) 时间缩放可以控制全局的时间，当值为 0 时为冻结模拟，值为 0.1 给出慢动作效果，值为 1.2 时给出加速效果。 1engine.timing.timeScale = 0.1; 这里就简单提及到几个属性，当然还有更多的属性比如：视图（View）、弹性（Restitution）等等，更详细的 API 可到官网查看。 Matter.js 调试除了前面讲 Matter.Render 模块的时候提到的线框模式 wireframes 便于调试外，Matter.Render 模块其实还为我们提供了以下几种方法，便于我们自定义调试选项： 1234567891011121314151617181920212223242526272829var render = Render.create(&#123; element: document.body, engine: engine, options: &#123; width: 800, height: 600, pixelRatio: 1, // 设置像素比 background: '#fafafa', // 全局渲染模式时背景色 wireframeBackground: '#222', // 线框模式时背景色 hasBounds: false, enabled: true, wireframes: true, // 线框模式 showSleeping: true, // 刚体睡眠状态 showDebug: false, // Debug 信息 showBroadphase: false, // 粗测阶段 showBounds: false, // 刚体的界限 showVelocity: false, // 移动刚体时速度 showCollisions: false, // 刚体碰撞点 showSeparations: false, // 刚体分离 showAxes: false, // 刚体轴线 showPositions: false, // 刚体位置 showAngleIndicator: false, // 刚体转角指示 showIds: false, // 显示每个刚体的 ID showVertexNumbers: false, // 刚体顶点数 showConvexHulls: false, // 刚体凸包点 showInternalEdges: false, // 刚体内部边界 showMousePosition: false // 鼠标约束线 &#125;&#125;); 另外官方提供了三个调试工具，可单独使用或一起使用，如下： 工具： MatterTools.Demo 用于运行和测试 DEMO MatterTools.Gui 改变引擎的属性 MatterTools.Inspector 检查世界 官方 DEMO 戳这里 下载 MatterTools.Demo MatterTools.Gui MatterTools.Inspector (依赖jQuery) 感谢你的阅读。 参考资料Matter.js - a 2D rigid body JavaScript physics enginliabru/matter-toolsPhysics engine - WikipediaMatter.js Demo","pubDate":"Mon, 17 Apr 2017 08:01:59 GMT","guid":"https://aotu.io/notes/2017/04/17/Matter-js/","category":"Web开发"},{"title":"Sticky Footer，完美的绝对底部","link":"https://aotu.io/notes/2017/04/13/Sticky-footer/","description":"写在前面做过网页开发的同学想必都遇到过这样尴尬的排版问题：在主体内容不足够多或者未完全加载出来之前，就会导致出现（图一）的这种情况，原因是因为没有足够的垂直空间使得页脚推到浏览器窗口最底部。但是，我们期望的效果是页脚应该一直处于页面最底部（如图二）： 笔者最近在项目中也遇到过这样的场景，在寻找最佳解决方案的过程中，了解到了 “Sticky Footer” 这个名词。本文将带大家重新认识这个常见的网页效果，以及一些可行的实现方案。 什么是 “Sticky Footer”所谓 “Sticky Footer”，并不是什么新的前端概念和技术，它指的就是一种网页效果：如果页面内容不足够长时，页脚固定在浏览器窗口的底部；如果内容足够长时，页脚固定在页面的最底部。总而言之，就是页脚一直处于最底，效果大致如图所示： 当然，实现这种效果的方法有很多种，其中有通过脚本计算的，有通过 CSS 处理的，脚本计算的方案我们不在本文探讨。下面我们看看有哪些通过 CSS 可以实现且适用于移动端开发的方案，并分析其中的利弊。 如何实现假设我们页面的 HTML 结构是这样： 1234&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;&lt;!-- 页面主体内容区域 --&gt;&lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;!-- 需要做到 Sticky Footer 效果的页脚 --&gt;&lt;/div&gt;&lt;/div&gt; 实现方案一：absolute通过绝对定位处理应该是常见的方案，只要使得页脚一直定位在主容器预留占位位置。 1234567891011121314html, body &#123; height: 100%;&#125;.wrapper &#123; position: relative; min-height: 100%; padding-bottom: 50px; box-sizing: border-box;&#125;.footer &#123; position: absolute; bottom: 0; height: 50px;&#125; 这个方案需指定 html、body 100% 的高度，且 content 的 padding-bottom 需要与 footer 的 height 一致。 实现方案二：calc通过计算函数 calc 计算（视窗高度 - 页脚高度）赋予内容区最小高度，不需要任何额外样式处理，代码量最少、最简单。 123456.content &#123; min-height: calc(100vh - 50px);&#125;.footer &#123; height: 50px;&#125; 如果不需考虑 calc() 以及 vh 单位的兼容情况，这是个很理想的实现方案。同样的问题是 footer 的高度值需要与 content 其中的计算值一致。 实现方案三：table通过 table 属性使得页面以表格的形态呈现。 123456789101112html, body &#123; height: 100%;&#125;.wrapper &#123; display: table; width: 100%; min-height: 100%;&#125;.content &#123; display: table-row; height: 100%;&#125; 需要注意的是，使用 table 方案存在一个比较常见的样式限制，通常 margin、padding、border 等属性会不符合预期。笔者不建议使用这个方案。当然，问题也是可以解决的：别把其他样式写在 table 上。 实现方案四：FlexboxFlexbox 是非常适合实现这种效果的，使用 Flexbox 实现不仅不需要任何额外的元素，而且允许页脚的高度是可变的。 虽然大多数 Flexbox 布局常用于水平方向布局，但别忘了实际上它也可用于垂直布局，所以你需要做的是将垂直部分包装在一个 Flex 容器中，并选择要扩展的部分，他们将自动占用其容器中的所有可用空间。 1234567891011html &#123; height: 100%;&#125;body &#123; min-height: 100%; display: flex; flex-direction: column;&#125;.content &#123; flex: 1;&#125; 需要注意的是想要兼容各种系统设备，需要兼顾 flex 的兼容写法。 写在最后以上几种实现方案，笔者都在项目中尝试过，每个实现的方法其实大同小异，同时也都有自己的利弊。其中有的方案存在限制性问题，需要固定页脚高度；其中有的方案需要添加额外的元素或者需要 Hack 手段。同学们可以根据页面具体需求，选择最适合的方案。 当然，技术是不断更新的，也许还有很多不同的、更好的方案。但相信大家最终目都是一样的，为了更好的用户体验！ 参考资料：https://css-tricks.com/couple-takes-sticky-footer/http://www.w3cplus.com/css3/css-secrets/sticky-footers.html","pubDate":"Thu, 13 Apr 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/04/13/Sticky-footer/","category":"移动开发"},{"title":"GPU加速是什么","link":"https://aotu.io/notes/2017/04/11/GPU/","description":"众所周知，网页不仅应该被快速加载，同时还应该流畅运行，比如快速响应的交互，如丝般顺滑的动画……一. GPU 加速能做什么？首先我们要了解什么是 16ms 优化 大多数设备的刷新频率是 60 次/秒，（1000/60 = 16.6ms）也就说是浏览器对每一帧画面的渲染工作要在 16ms 内完成，超出这个时间，页面的渲染就会出现卡顿现象，影响用户体验。 浏览器在一帧里面，会依次执行以下这些动作。减少或者避免 layout，paint 可以让页面不卡顿，动画效果更加流畅。 JavaScript：JavaScript 实现动画效果，DOM 元素操作等。 Style（计算样式）：确定每个 DOM 元素应该应用什么 CSS 规则。 Layout（布局）：计算每个 DOM 元素在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow。 Paint（绘制）：在多个层上绘制 DOM 元素的的文字、颜色、图像、边框和阴影等。 Composite（渲染层合并）：按照合理的顺序合并图层然后显示到屏幕上。 利用 GPU 加速优先使用渲染层合并属性，避免 layout，paint。 从上图可以看出，可以通过改变元素的 transform 实现移动，伸缩变换而非改变物体的 left，top，width，height 避免 layout，paint。让动画效果更加流畅。 123456789@keyframes demo &#123; 0% &#123; top: 10px; &#125; 100% &#123; top: 30px; &#125;&#125; 优化123456789@keyframes demo &#123; 0% &#123; transform: translateY(10px); &#125; 100% &#123; transform: translateY(30px); &#125;&#125; 二. GPU 是什么，如何用 Chrome devtools 进行分析 debug？浏览器渲染一个页面大致是按照下面这个步骤执行。 获取 DOM 并将其分割为多个层(RenderLayer) 将每个层栅格化，并独立的绘制进位图中 将这些位图作为纹理上传至 GPU 复合多个层来生成最终的屏幕图像(终极 layer )。 Chrome 开启查看 renderlayer 按上面的步骤之后，即可看到 黄色边框：有动画 3d 变换的元素，表示放到了一个新的复合层（composited layer）中渲染 蓝色的栅格：这些分块可以看作是比层更低一级的单位，这些区域就是 RenderLayer打开一个页面，如果该页面的黄色边框很多，那么肯定要查看一下原因了 Chrome 查看 layer 打开 timeline 进行录制，选中 timeline 的某一帧，然后选择下面的 layer ，可以左右拖动该模块出现 3d。我们可以看到一个页面实际是像下面一样组成的 从上图不难理解，虽然我们最终在浏览器上看到的只是一个复印版，即最终只有一个层。类似于PhotoShop软件中的“图层”概念，最后合并所有可视图层，输出一张图片到屏幕上。但实际上一些dom会因为一些规则被提升成独立的层（开启 GPU 加速），一旦被独立出来之后，便不会再影响其他dom的布局，因为它改变之后，只是“贴上”了页面。 根据这个优点，我们可以把页面中一些布局经常变换的dom（动画）提升到独立的层。那么，浏览器在之后的 16ms 中，只需进行下面的几个步骤。 三. 如何开启 GPU 加速？目前下面这些因素都会引起Chrome创建合成层： 3D 或透视变换(perspective，transform) CSS 属性 使用加速视频解码的video元素 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 canvas 元素 混合插件(如 Flash) 对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素 拥有加速 CSS 过滤器的元素 元素A有一个 z-index 比自己小的元素B，且元素B是一个合成层（换句话说就是该元素在复合层上面渲染），则元素A会提升为合成层 上面6点都非常容易理解，在日常开发中，最容易出现问题的是第7点 四. GPU 加速隐藏的坑–隐式合成 元素A有一个 z-index 比自己小的元素B，且元素B是一个合成层（换句话说就是该元素在复合层上面渲染） 拿实际项目举个栗子，我们按照上面的步骤开启 layer borders 尚未给上图右手添加高层级的 z-index 时，整个页面在移动端打开后闪退。而添加了 z-index 之后，页面正常显示，不闪退了。仔细看上面的 gif ，仅仅改变了 z-index ，就会改变大批数量的层（黄色边框） 为什么 z-index 力量这么大？我们来看一个栗子，B 在做动画，理所当然把B提到单独的合成层。减少重绘。 按照上图，我们遇到一个逻辑问题，元素B应该在单独的合成层上，并且屏幕的最终图像应该在 GPU 上组成。但是A元素在B元素的顶部，我们没有指定提升A元素自身层级的东西。那么浏览器会做什么？它将强制为元素A创建一个新的合成图层。这样，A和B都被提升到单独的复合层。因此，使用 GPU 加速提升动画性能时，最好给当前动画元素增加一个高一点的 z-index 属性，人为干扰复合层的排序，可以有效减少 Chrome 创建不必要的复合层，提升渲染性能。 注意：GPU 不仅需要发送渲染层图像到 GPU ，而且还需存储它们，以便稍后在动画中重用。别盲目创建渲染层，一定要分析其实际性能表现。因为创建渲染层是有代价的，每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。对于使用移动设备的用户来说是很坑的。移动设备没有台式机那么多的内存。过多的 GPU 加速会引起页面卡顿甚至闪退。 找到 layers，点击当前层，在右边查看占用的 memory（内存） 总结整篇文章介绍了下面几个部分 GPU 加速能做什么 GPU 是什么，如何用 Chrome devtools 进行分析 debug？ 如何开启 GPU 加速？ GPU 加速隐藏的坑–隐式合成 参考： http://www.jianshu.com/p/a32b890c29b1 http://div.io/topic/1348","pubDate":"Tue, 11 Apr 2017 02:25:35 GMT","guid":"https://aotu.io/notes/2017/04/11/GPU/","category":"移动开发"},{"title":"了解 Fetch API","link":"https://aotu.io/notes/2017/04/10/fetch-API/","description":"背景提及前端与服务器端的异步通信，离不开 Ajax (Asynchronous JavaScript and XML)。实际上我们常说的 Ajax 并非指某一项具体的技术，它主要是基于用脚本操作 HTTP 请求的 Web 应用架构。最早出现在 Jesse James Carrett 于 2005年2月发表一篇《Ajax：A New Approach to Web Applications》中提出的一个新概念。 在 Ajax 中涉及到的 JavaScript 方面的技术，即 XMLHttpRequest（以下简称 XHR）。很长一段时间我们都是通过 XHR 来与服务器建立异步通信。然而在使用的过程中，我们发现 XHR 是基于事件的异步模型，在设计上将输入、输出和事件监听混杂在一个对象里，且必须通过实例化方式来发请求。配置和调用方式混乱，不符合关注分点离原则。 关注点分离原则所描述的是系统的元素应该表现出互不相干的目的。也就是说，没有会分担另外一个元素职责的，或者其它不相干职责的元素。 正是由于 XHR 在使用上的不便，许多前端库就将进行封装，方便开发者调用。其中影响和使用范围最广的当属 jQuery 提供的 $.ajax 方法。该方法最为先进之处在于，从 jQuery 1.5 开始，$.ajax()返回的jqXHR对象 实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为。 直到 Fetch API 的提出，前端和服务器端的异步通信方面更进了一步。 技术介绍Fetch API 是近年来被提及将要取代 XHR 的技术新标准，是一个 HTML5 的 API。 Fetch 并不是 XHR 的升级版本，而是从一个全新的角度来思考的一种设计。Fetch 是基于 Promise 语法结构，而且它的设计足够低阶，这表示它可以在实际需求中进行更多的弹性设计。对于 XHR 所提供的能力来说，Fetch 已经足够取代 XHR ，并且提供了更多拓展的可能性。 快速了解Fetch API 规范明确了用户代理获取资源的语义。原生支持 Promise1，调用方便，符合语义化。可配合使用 ES2016 中的 async / await 语法，更加优雅。 通过一个例子来快速了解和使用 Fetch API 最基本的用法 12345678910111213141516171819202122// 获取 some.json 资源fetch('some.json') .then(function(response) &#123; return response.json(); &#125;) .then(function(data) &#123; console.log('data', data); &#125;) .catch(function(error) &#123; console.log('Fetch Error: ', error); &#125;);// 采用ES2016的 async/await 语法async function() &#123; try &#123; const response = await fetch('some.json'); const data = response.json(); console.log('data', data); &#125; catch (error) &#123; console.log('Fetch Error: ', error) &#125;&#125; 通过例子我们可以发现，使用 Fetch API 能够快速便捷地进行资源地获取。 可以简单理解为，Fetch API 是面向未来的异步通信 API。 具体用法fetch 方法fetch 方法有两种调用方式。 12Promise fetch(String url, [, Object options])Promise fetch(Request req, [, Object options]) 第一个参数是一个 Request 对象，第二个参数是配置信息，可选 第一个参数是一个 url，第二个参数是配置信息，可选 可选配置信息是一个 Object 对象，可以包含以下字段： method: 请求的方法，例如：GET, POST。 headers: 请求头部信息，可以是一个简单的对象，也可以是 Headers 类实例化的一个对象。 body: 需要发送的信息内容，可以是 Blob, BufferSource, FormData, URLSearchParams 或者 USVString。注意，GET, HEAD方法不能包含body。 mode: 请求模式，分别有 cors, no-cors, same-origin, navigate 这几个可选值。 cors: 允许跨域，要求响应中 Acess-Control-Allow-Origin 这样的头部表示允许跨域。 no-cors: 只允许使用 HEAD, GET, POST方法。 same-origin: 只允许同源请求，否则直接报错。 navigate: 支持页面导航。 credentials: 表示是否发送cookie，有三个选项 omit: 不发送cookie。 same-origin: 仅在同源时发送cookie。 include: 发送cookie。 cache: 表示处理缓存的策略。 redirect: 表示发生重定向时，有三个选项 follow: 跟随。 error: 发生错误。 manual: 需要用户手动跟随。 integrity: 包含一个用于验证资资源完整性的字符串。 HeadersHeaders 可用来表示 HTTP 的头部信息，使用 Headers 的接口，你可以通过 Headers() 构造函数来创建一个你自己的 headers 对象。 12345678var headers = new Headers(&#123; \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\",&#125;);headers.append(\"X-Custom-Header\", \"AnotherValue\");headers.has(\"Content-Type\") // trueheaders.getAll(\"X-Custom-Header\"); // [\"ProcessThisImmediately\", \"AnotherValue\"] Header\u0005s 提供 append, delete, get, getAll, has, set, forEach等这些实例方法，可供开发者更加灵活地配置请求中的 headers。 RequestRequest 类用于描述请求内容。构造函数接受的参数与fetch方法一致，这里就不展开介绍了。我们可以这么理解，事实上fetch方法在调用时，会将传入的参数构造出一个 Request 对象并执行。 1234567var URL = '//api.some.com';var getReq = new Request(URL, &#123;method: 'GET', cache: 'reload'&#125;);fetch(getReq).then(function(response) &#123; return response.json();&#125;).catch(function(error) &#123; console.log('Fetch Error: ', error);&#125;); Request 接口中的配置项 headers 可以是实例化的 Headers 。 12345678910111213var URL = '//api.some.com';// 实例化 Headersvar headers = new Headers(&#123; \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\",&#125;);var getReq = new Request(URL, &#123;method: 'GET', headers: headers &#125;);fetch(getReq).then(function(response) &#123; return response.json();&#125;).catch(function(error) &#123; console.log('Fetch Error: ', error);&#125;); 更便捷的是，Request 对象可以从已有的 Request 对象中继承，并拓展新的配置。 1234var URL = '//api.some.com';var getReq = new Request(URL, &#123;method: 'GET', headers: headers &#125;);// 基于已存在的 Request 实例，拓展创建新的 Request 实例var postReq = new Request(getReq, &#123;method: 'POST'&#125;); ResponseResponse 实例是在fentch()处理完promises之后返回的。它的实例也可用通过JavaScript来创建，但只有在ServiceWorkers中才真正有用。 1var res = new Response(body, init); 其中 body 可以是 Bolb, BufferSource, FormData, URLSearchParams, USVString 这些类型的值。 init 是一个对象，可以包括以下这些字段 status: 响应状态码 statusText: 状态信息 headers: 头部信息，可以是对象或者Headers实例 Response 实例提供了以下实例属性，均是只读属性。 bodyUsed: 用于表示响应内容是否被使用过 headers: 头部信息 ok: 表明请求是否成功，响应状态为 200 ~ 299 时，值为 true status: 状态码 statusText: 状态信息 type: 响应类型 basic: 同源 cors: 跨域 error: 出错 opaque: Request mode 设置为 “no-cors”的响应 url: 响应地址 Response 实例提供以下实例方法。 clone: 复制一个响应对象。 arrayBuffer: 将响应数据转换为 arrayBuffer 后 reslove 。 bolb: 把响应数据转换为 Bolb 后 reslove 。 formData: 把响应数据转换为 formData 后 reslove 。 json: 把响应内容解析为对象后 reslove 。 text: 把响应数据当做字符串后 reslove 。 浏览器支持 Chrome 45+， Opera 44+，Firefox 51+ 和 IE Edge 等这些版本的浏览器开始支持 Fetch API。移动端浏览器也在逐步得到支持。 我们可以通过对 window.fetch 的能力检测，判断出浏览器是否支持 Fetch API。github 官方推出了一个 Fetch API 的 polyfill 库，可以让更多浏览器提前感受到 Fetch API 的便捷的开发体验。 结语虽然 Fecth API 使用方便符合语义化，但是现阶段它也有所限制。Fetch API 是基于 Promise，由于 Promise 没有处理 timeout 的机制，所以无法通过原生方式处理请求超时后的中断，和读取进度的能力。但是相信未来为了支持流，Fetch API 最终将会提供可以中断执行读取资源的能力，并且提供可以读取进度的 API。 参考文档 使用Fetch 【翻译】这个API很“迷人”——(新的Fetch API)","pubDate":"Mon, 10 Apr 2017 06:24:32 GMT","guid":"https://aotu.io/notes/2017/04/10/fetch-API/","category":"Web开发"},{"title":"用 Git 钩子进行简单自动部署","link":"https://aotu.io/notes/2017/04/10/githooks/","description":"Git 钩子Git 钩子(hooks)是在 Git 仓库中特定事件(certain points)触发后被调用的脚本。通过钩子可以自定义 Git 内部的相关（如 git push）行为，在开发周期中的关键点触发自定义的行为。Git 含有两种类型的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 Git 钩子最常见的使用场景包括根据仓库状态改变项目环境、接入持续集成工作流等。由于脚本是可以完全定制，所以你可以用 Git 钩子来自动化或者优化你开发工作流中任意部分。 在这篇文章中，我们会先简要介绍 Git 钩子相关要素，然后实例使用 Git 钩子进行博客自动部署。 Git 钩子安装Git 钩子存在于每个 Git 仓库的 .git/hooks 目录中。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。 1234➜ hooks git:(master) lsapplypatch-msg.sample pre-applypatch.sample pre-rebase.samplecommit-msg.sample pre-commit.sample prepare-commit-msg.samplepost-update.sample pre-push.sample update.sample .sample拓展名是为了防止它们默认被执行，安装一个钩子只需要去掉.sample拓展名即可。 Git 钩子的作用域Git 钩子是对本地仓库相关操作影响，对于任何 Git 仓库来说钩子都是本地的，初始的钩子都是从 Git 默认模板目录中自动安装。 在开发团队中为了保持团队所使用钩子一致，维护起来算是比较复杂的，因为 .git/hooks 目录不随你的项目一起拷贝，也不受版本控制影响。 简单的解决办法是把钩子文件存放在项目的实际目录中（在.git 外），这样就可以像其他文件一样进行版本控制，然后在.git/hooks中创建一个链接，或者简单地在更新后把它们复制到.git/hooks目录下。 当我们了解了以上 Git 钩子基础知识后，下面我们来实例操作 Git 钩子进行博客自动部署。 Git 钩子进行自动部署如何实现 Git 钩子进行自动部署，其实原理很简单，我们只需要监听每次本地 git push到远程服务器，然后远程服务器同步拉取最新文件，重启服务器即可（pm2 reload xx）。 1.在服务器初始化一个远程 Git 裸仓库 (git init –bare) 裸仓库与 git init 初使化的仓库不太一样，裸仓库其实相当于通过克隆来的仓库里的.git文件夹，整个裸仓库中只有git索引（index），不包含工作目录。要实现 Push to Deploy，首先我们需要一个裸仓库，进入/home/USER/repos/，创建如下： 1234567git init --bare xxx-bare.git或mkdir xxx-bare.gitcd xxx-bare.gitgit init --bare 2.配置 Git Hook 将目录切换至 /home/USER/repos/xxx-bare.git/hooks，用 cp post-update.sample post-update 复制并重命名文件后 vim post-update 修改，增加执行脚本: 123456789101112#!/bin/shunset GIT_DIR DIR_ONE=/home/user/www/blog／ #此目录为服务器页面展示目录 cd $DIR_ONEgit initgit remote add origin ~/repos/xxx-bare.gitgit clean -dfgit pull origin masterpm2 restart xxx #pm2重启项目即可 注意： 一定要unset GIT_DIR清除变量， 不然会引起remote: fatal: Not a git repository: ‘.’错误。 post-update添加执行权限： 1chmod +x post-update 3.本地仓库添加 remote 源 本地仓库添加远程仓库源之后，一旦本地仓库变更提交就会触发 Git 钩子，驱动自动部署 1234git initgit remote add origin user@1.2.3.4:/home/USER/repos/xxx-bare.git #添加远程仓库源//例如git remote add origin ssh://root@41.72.11.11:26244/home/USER/repos/xxx-bare.git #远程仓库带端口写法git push origin master 最后以上就是本次 Git 钩子相关知识，希望通过本文，能让大家对 Git 钩子有一定的了解。","pubDate":"Mon, 10 Apr 2017 04:52:57 GMT","guid":"https://aotu.io/notes/2017/04/10/githooks/","category":"Web开发"},{"title":"实现一个简单但有趣的AR效果（Web）","link":"https://aotu.io/notes/2017/03/24/webar/","description":"增强现实（Augmented Reality，简称AR）：是一种实时地计算摄影机影像的位置及角度并加上相应图像、视频、3D模型的技术，这种技术的目标是在屏幕上把虚拟世界套在现实世界并进行互动。 本文将让你了解“如何通过 Web 技术实现一个简单但有趣的 AR 效果”。 实现分析正如文章开头说道：AR 是将真实环境与虚拟物体实时地叠加到一个画面。因此我们需要通过摄像头实时获取真实环境，并通过识别算法识别与分析真实环境中特定的物体，然后结合得到的数据，将虚拟物体以某种方式结合到画面中。 结合我们的案例，可得出以下步骤： 获取视频源 分析源，并识别出 Marker 位置 将虚拟物体叠加在 Marker 上 将最终画面显示在屏幕上 下面我们就根据以上步骤逐点分析。 技术分析获取视频源不依赖 Flash 或 Silverlight，我们使用 navigator.getUserMedia() API，该 API 允许 web 应用获取用户的摄像头与麦克风流（stream）。 123456789101112131415161718192021222324252627282930313233&lt;!-- 若不加 autoplay，则会停留在第一帧 --&gt;&lt;video autoplay&gt;&lt;/video&gt;navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;var video = document.querySelector('video');var constraints = &#123; video: true&#125;function successCallback(stream) &#123; // 此处利用该 window.URL 对象的 createObjectURL 方法将 blob 转为 url。 if (window.URL) &#123; video.src = window.URL.createObjectURL(stream); // 用来创建 video 可以播放的 src &#125; else &#123; video.src = stream; &#125;&#125;function errorCallback(error) &#123; console.log('navigator.getUserMedia error: ', error);&#125;if (navigator.getUserMedia) &#123; navigator.getUserMedia(&#123;video: true&#125;, successCallback, errorCallback);&#125; else &#123; console.log('getUserMedia() is not supported in your browser') video.src = 'somevideo.webm'; // fallback.&#125; 上述 API 已不被推荐，建议使用新标准 API：navigator.mediaDevices.getUserMedia()。12345navigator.mediaDevices.getUserMedia(constraints).then(function(stream) &#123; /* use the stream */&#125;).catch(function(err) &#123; /* handle the error */&#125;); 另外，可通过 constraints 参数设置以下选项： 启用 video、audio 二者其一或两者同时启用 匹配摄像头分辨率（若设备拥有不止一个摄像头） 选择前后摄像头 navigator.getUserMedia() 兼容性问题目前 IOS 设备的微信和 Safari 均不支持，较新的安卓和桌面端浏览器均支持。 另外，出于安全问题考虑，Chrome 只支持 HTTPS 页面启用摄像头。因此，我们可以用 Firefox，或者借助一些线上编辑器，如 jsbin、jsFiddle 等进行开发测试。 识别得到视频源后，我们需要对图像中的物体（本案例是 Marker）进行实时识别。下面提供两个可实现识别的库： jsaruco jsartoolkit 正如其名，它们是 aruco 和 artoolkit 的 JavaScript 版本。本文仅对第一个库进行介绍。 ArUco 是一个基于 OpenCV 的 AR 轻量库。 OpenCV（Open Source Computer Vision Library）：是一个跨平台的计算机视觉库。它可用于开发实时的图像处理、计算机视觉以及模式识别程序。 jsaruco 能识别视频每帧画面中的 Marker 位置（含 4 个角坐标）。获取坐标后，我们就能将虚拟物体放在真实环境的适当位置了。关于 jsaruco 的介绍和用法，可到 这里 查看。 结合真实环境和虚拟物体对图像的处理，Canvas（WebGL） 无疑是目前 Web 的最佳选择。 虚拟对象若是 2D 的，则直接利用 Canvas 2D API 在相应坐标上进行绘制。若虚拟对象是 3D 的，则可使用 Three.js 或 A-Frame 等 3D 库（当然，你也可以直接用 WebGL）。 如果你对 Three.js 还不了解，可以看看 《Three.js入门指南》。 另外，使用 A-Frame 可让你更快和更轻易地体验到 3D 的乐趣，仅需 10 行代码即可实现 AR，具体可阅读这篇文章 《Augmented Reality in 10 Lines of HTML》。 Marker 分析每个识别库都有其自身的实现方式。因此，一些 Marker 可能只适用于某个库。对于 jsaruco，它对 Marker 的要求如下： 一个 7x7 的正方形，其外层是“不用”的黑边。内部 5x5 单元格则组成了 ID 信息。其中，每行需要遵循以下模式： white - black - black - black - blackwhite - black - white - white - whiteblack - white - black - black - whiteblack - white - white - white - black 因此，根据上述信息，我们可以得出该库最多可识别 1024（4的5次方） 个 Marker。也就是说：每个 Marker 对应唯一一个 ID，然后我们可以利用 ID 指定显示的虚拟对象。 一个合格的 Marker 应该是这样子： 可通过这个 链接，获取 jsaruco 的更多 Marker。 当然，更先进的图像识别库不仅能识别 Marker，也可以识别你指定的图片，甚至是自然特征跟踪（ Natural Feature Tracking）和 SLAM（Simultaneous Localization and Mapping，即时定位与地图构建）。 自然特征跟踪 SLAM 实现案例建议使用带有摄像头的电脑体验以下案例（注意不要被自己的头像惊艳到~）。 另外，由于以下案例均未要求特定 ID 的 Marker，因此你可以选择以下 Marker（拍照或打印），或者在 这里 挑选一个进行体验。 Marker 想体验以下案例，需要先对某一个 Marker 拍下或打印，然后将其展示在摄像头前。 另外，为了保持文章的简洁，在此就不直接展示以下案例的实现代码。若需要，则直接查看案例源码。 再次提醒：以下案例均在电脑上进行开发测试，未针对移动端设备进行优化测试。 除了第一个案例，其余均以动画的方式展示虚拟元素。 显示 2D 图当你展示团队 Logo 时，链接&gt;&gt;。 显示心跳当你看到“男神/女神”时，链接&gt;&gt;。 显示卡片当需要展示某个人的身份信息时，链接&gt;&gt;。 显示 3D 地球当展示我们的地球母亲时，链接&gt;&gt;。 显示 3D 商品。当展示我们的商品时，链接&gt;&gt;。 最后由于笔者才疏学浅，实现的案例未必完全符合 AR 的要求。但希望通过本文，让大家能对 Web AR 有一定的了解。 参考文档 Augmented Reality in Three.js Three.js入门指南 MDN : MediaDevices.getUserMedia() js-aruco","pubDate":"Fri, 24 Mar 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/03/24/webar/","category":"Web开发"},{"title":"轻氧 - React Native 安卓版 V1.0","link":"https://aotu.io/notes/2017/03/03/liteo2-android/","description":"距 轻氧 iOS版上一次发版本已经快一个月。 一个月可以做很多件事情，具有 加藤鹰の右手手速 的男前端童鞋可以做4到5个甚至更多的互动H5活动；但也可以只做一件事情，我们阿尔法突击队三个小伙伴过去这个月就只做了本次的 轻氧 安卓 V1.0，从交互到设计到编码实现再到申请上架。 我们慢，除了因为我们是新手（完全没有安卓 APP 开发经验，其中一名叫马克林的童鞋还是专职的 iOS 开发~），还因为我们足够用心和耐（cai）心（keng）。 我们依然是新技术控，在iOS版本中我们追随了 Swift 3.0，而在本次的安卓版本中我们选择了 React Native，尽管它的 JSX 语法相当的蹩脚丑陋，且版本号还是距离 1.0 相当遥远的 0.4x。 我们没有忘记在公众号（凹凸实验室）里留言召唤安卓版的同学们，所以现在神龙出现了。 版本功能在 iOS 版开发过程中存在版本规划过于粗放导致开发周期拖沓的问题，我们在开发安卓版前细化了版本计划，更细的版本规划可以让我们保持 小步快跑，快速迭代 的敏捷开发理念，通过 上线-反馈-修改-上线 的反复迭代来逐步改进产品。 V1.0 是一个基础版本，它的核心功能是满足大家阅读、分享和检索轻氧资讯的诉求，在此版本里你可以： 随时浏览国内外知名互联网公司的交互、设计、前端以及 APP 等资讯动态信息 一键分享资讯至微信好友/朋友圈 搜索资讯，在 10000+ 资讯中找到你最感兴趣的内容 根据大数据将资讯标签化，点击标签即可找到更多相似的文章 接收由编辑挑选出精华文章和热点资讯推送 功能自然是没有 iOS 版本丰富，我们后续会继续给它填充血肉。我们计划在 V1.1 版本中加入账户体系，在 V1.2 加入评论等简单社交功能。 此外，鉴于 RN 的局限性，相对于iOS版本我们舍弃了很多的交互动效，也因此让整个安卓版的 APP 显得更简单直接，这未尝不是一件好事。 聊聊 React Native还记得去年底我们说要用 Weex 实现安卓版本，但不好意思那只是一个漂亮的假动作 XD。经过一番调研之后，我们发现 Weex 并不适合拿来写一个独立的 APP 产品。主要来说，它有以下几点缺陷： Weex 没有完整的路由组件 目前版本还没有稳定下来，官方某些组件存在不刷新的问题 第三方插件远不如 RN 的丰富 既然如此，那市面上就只有 React Native 了。虽说《某某公司在 React Native 实践中踩过的坑》的文章也看了不少，但我们还是毅然决断地随了大流。 果不其然，在踩进了坑之后，我们在开发中也发现了 RN 的一些缺陷： ListView 并没有实现复用机制，会带来额外的性能开销 WebView 没有 onScroll 回调，需要通过消息通知方式获取滚动的偏移量 RN 的升级和降级需要小心翼翼，一不小心就碰上了大麻烦 RN 的某些动画存在掉帧的情况，特别是数据量大的情况下 当然没有技术是完美的。抛开这些缺陷来说，RN 在效率上所带来的巨大提升，还是让人十分吃惊的。相对于 iOS 原生开发来说，用上 RN 后，我们再也不必为了调样式，而去上一次厕所（等待 build 完成…）。 不仅仅是开发上带来的便利。在 APP 上线之后，如果发现有什么 bug，我们也可以利用一些热更新机制，实现静默更新。 总的来说，RN 是一个很高效而且性能不错的框架，值得你去深入尝试。 下载体验很高兴安卓 V1.0 版本已经上架了，如果你有兴趣，欢迎点击这里前往应用宝下载试用。目前应用内还没整合反馈渠道，如果你有任何的想法，欢迎在文末留言，或者给我们来信，我们会回复每一封邮件。邮箱是 aotu#jd.com(# 改为 @)。 关于也许你是轻氧的潜在用户，所以还是在文末唠叨下 轻氧 是什么。 轻氧 是 凹凸实验室 出品的一款互联网专业资讯 APP，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一口气把业界最优质的专业资讯文章读完，只要你这口气够长。 轻氧 精心选出了一些知名的 UED 和互联网站点，基于其简易信息聚合协议（RSS），将优质的互联网内容包装和分发，聚集到一个平台。 轻氧 搬运但不盗窃，如果你喜欢，你仍然可以把「轻氧」当成是一款RSS订阅器，尽管我们不止于订阅辣么简单，后续我们APP做开源分享的时候再做深入介绍。 经过半年时间的耕耘，轻氧目前已有超过 11000 篇资讯，来自于 40+ 资讯来源： 未来，我们还将在保证高质量文章的基础上，聚合更多的来源。","pubDate":"Fri, 03 Mar 2017 08:45:36 GMT","guid":"https://aotu.io/notes/2017/03/03/liteo2-android/","category":"移动开发"},{"title":"移动端真机调试指南","link":"https://aotu.io/notes/2017/02/24/Mobile-debug/","description":"导语：随着移动设备的普及以及微信庞大的用户量，移动端的需求也随之爆发式增长，平时我们使用 Chrome 进行手机模拟页面开发，但模拟终究是模拟，不可避免的还是需要真机调试，下面就来讲讲几种调试方案，希望能对你有所帮助。 系统自带调试功能iOS 系统运行环境要求 Mac + Safari 浏览器 iPhone（iOS 6 +） + Safari 浏览器 调试步骤 1、使用 Lightning 数据线将 iPhone 与 Mac 相连 2、iPhone 开启 Web 检查器（设置 -&gt; Safari -&gt; 高级 -&gt; 开启 Web 检查器） 3、iPhone 使用 Safari 浏览器打开要调试的页面 4、Mac 打开 Safari 浏览器调试（菜单栏 —&gt; 开发 -&gt; iPhone 设备名 -&gt; 选择调试页面） 如果你的菜单栏没有“开发”选项，可以到左上角 Safari -&gt; 偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示“开发”菜单。 5、在弹出的 Safari Developer Tools 中调试 经过如上步骤就可在 Mac 端调试 iPhone 上 Safari 运行的页面了，但对于 WebView 页面就不适用了，另外 Windows 系统不适用此方案。 当前测试环境： Safari 版本 10.0.2 iPhone 7（iOS 10.1.1） 没有 iPhone 设备可以在 App Store 安装 Xcode 使用其内置的 iOS 模拟器，安装完成后通过以下两种方式开启： 右键 Xcode 图标 -&gt; Open Developer Tool -&gt; Simulator 右键 Finder 图标 -&gt; 前往文件夹 -&gt; /应用程序/Xcode.app/Contents/Developer/Applications/ -&gt; 运行 Simulator.app 运行 iOS 模拟器后，在模拟器中打开调试页面，再通过 Mac Safari 开发功能就可以调试到。 如果我需要调试更低版本的 iOS 怎么办？实际使用的 iPhone 不可能去降版本，不必担心，Simulator 有。 点击左上角 Xcode -&gt; Preferences -&gt; Downloads 就可以看到提供了如下版本： Android 系统运行环境要求 Chrome 版本 &gt;= 32 Android 版本 4.0 + 调试步骤 1、使用 USB 数据线将手机与电脑相连 2、手机进入开发者模式，勾选 USB 调试，并允许调试 如何开启 USB 调试： 索尼 Z5：设置 -&gt; 关于关机 -&gt; 多次点击软件版本开启 -&gt; 返回上一级 -&gt; 开发者选项 -&gt; USB 调试 魅蓝 Note：设置 -&gt; 辅助功能 -&gt; 开发者选项 -&gt; USB 调试 不同 Android 设备进入开发者模式的方式有稍稍不同，瞎捣鼓一下即可开启。 3、电脑打开 Chrome 浏览器，在地址栏输入：chrome://inspect/#devices 并勾选 Discover USB devices 选项 4、手机允许远程调试，并访问调试页面 官方的教程是想让你使用手机 Chrome 开启调试页面的，但实际需求更多的是调试一些 WebView 页面，在官方的 Remote Debugging WebViews 有说明是可以调试 WebView 页面的，Android 版本需要在 4.4 以上，并且 APP 需要有配置相应的启动调试代码。 WebView debugging must be enabled from within your application. To enable WebView debugging, call the static method setWebContentsDebuggingEnabled on the WebView class. 必须在 APP 内启动 WebView 调试。要启动 WebView 调试，需要调用 WebView 类上的静态方法 setWebContentsDebuggingEnabled。 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true);&#125; This setting applies to all of the application’s WebViews. 此设置适用于所有 APP 的 WebView。 Tip: WebView debugging is not affected by the state of the debuggable flag in the application’s manifest. If you want to enable WebView debugging only when debuggable is true, test the flag at runtime. 提示：WebView 是否可调试状态不受 mainfest 标志变量 debuggable 的影响，如果你想在 debuggable 为 true 的时候启动 WebView 调试，请使用以下代码： 12345if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; if (0 != (getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE)) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125;&#125; 5、电脑点击 inspect 按钮 如果你出现无法识别到设备的情况，建议尝试以下几种方法： 使用原装数据线，不要使用山寨数据线或一线多头的数据线 重新插拔 USB 数据线，让手机处于充电状态 关闭电脑相关的应用助手 重启手机 Windows 系统下自动安装驱动失败，到 Android Studio 手动下载 注意：使用 Chrome Inspect 查看页面时，Chrome 需要从 https://chrome-devtools-frontend.appspot.com 加载资源，如果你得到的调试界面是一片空白，那你可能需要科学上网。 6、进入调试界面 当前测试环境： Chrome 版本 55.0.2883.95 索尼 Z5（Android 5.1.1） 魅蓝 Note（Android 5.1） 三星 Galaxy S7（Android 6.0.1） 这里顺带提一下 TBS Studio 调试工具，它在 Chrome DevTools 调试功能的基础上进行了一些功能扩展，特性如下： 1.3 TBS Studio 功能特性 1）自动检测手机与 PC 的连接；2）自动检测网页是否可进行 Inspect 调试；3）自动引导开发者打开 Inspector 调试开关；4）一键开启 Inspector 调试，无需打开浏览器输入 URL，方便快捷；5）扩展 X5 内核独有 Inspect 选项，方便页面分析和优化；6）真机远程 Inspector 调试。 详细介绍和使用步骤可到开发者论坛查看，部分 Android 机型通过 USB 可能依旧无法识别到设备，可使用后面会讲到的其他方案。 关于 Android 虚拟机也是有的，这里推荐使用 Genymotion 软件，使用 Genymotion 前需要安装 VirtuaBox，并且注册登陆后才能显示所有的虚拟设备。 使用代理工具调试开发环境页面对于需要配 Hosts 才能访问的开发环境页面，手机在默认情况下是没有权限修改 Hosts 文件的，除非是 iOS 设备越狱后和 Android 设备 root 后，所以一般情况下手机是无法访问开发环境页面，这时需要使用到 Mac 系统的 Charles 代理工具，Windows 系统可使用 Fiddler 代理工具。 实现思路 Mac 作为代理服务器 手机通过 HTTP 代理连接到 Mac 电脑 手机上的请求都经过代理服务器 通过给 Mac 配 Hosts 实现目的 调试步骤 1、查看电脑 IP（菜单 -&gt; Help -&gt; Local IP Addresses） 2、查看端口（菜单 -&gt; Settings -&gt; Proxy Settings -&gt; Proxies） 默认端口为：8888，勾选 Enable transparent HTTP proxying 3、将 IP、端口号填入手机 HTTP 代理 iOS 系统：设置 -&gt; 无线局域网 -&gt; 点击叹号 -&gt; HTTP 代理 -&gt; 手动 Android 系统：设置 -&gt; 长按当前网络 -&gt; 修改网络 -&gt; 高级选项 -&gt; 手动 4、Charles 允许授权 每次有新设备首次连接都会提示是否授权，可以通过 Proxy -&gt; Access Control Settings 配置以下参数 0.0.0.0/0 来关闭。 5、使用 SwitchHosts! 软件给 Mac 电脑配 Hosts 6、手机访问开发环境页面 到这一步手机就可以访问到开发环境下的页面了，再结合前面所讲的方案来调试页面。 7、Charles 的调试功能 7.1 网络映射修改文件 除了结合前面的方案调试，可以使用 Map Local 网络映射功能来实现对文件的修改，在菜单 -&gt; Proxy -&gt; Start Recording 开启抓包后访问页面，找到抓取到的样式文件，点击右键 Map Local，在 Local path 中设置本地映射文件的路径，修改后刷新页面可以看到效果。 7.2 模拟网络速度 菜单 -&gt; Proxy -&gt; Throttle Settings -&gt; 勾选 Enable Throttling，在 Throttling preset 中可以选择需要模拟的网络速度。 7.3 抓取 HTTPS 请求 默认情况下，Charles 无法抓取到 HTTPS 的请求，解决步骤如下： Mac 端安装证书：菜单 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate 然后导出 Charles SSL 证书安装到手机，菜单 -&gt; Help -&gt; SSL Proxying -&gt; Save Charles Root Certificate Android 设备导出的 Charles SSL 证书存储到手机中并安装。 iOS 设备用 Safari 打开 http://www.charlesproxy.com/getssl/ 页面，下载 Charles SSL 证书并安装。 证书安装完成后，还需要给 Charles SSL 代理配置域名和端口号，菜单 -&gt; Proxy -&gt; SSL Proxying Settings 勾选 Enable SSL Proxying 点击 Add 填入域名和端口号，经过以上步骤就可以抓取到 HTTPS 的请求了。 7.4 断点调试请求和响应内容 开启 Charles 断点 Proxy -&gt; Breakpoints Settings -&gt; Enable Breakpoints点击 Add 可设置断点条件或者单独对需要的文件右键 Breakpoints 设置断点。 访问页面后，即可编辑请求和响应的内容，点击 Execute 按钮完成。 Weinre 调试工具Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。 调试步骤： 1、安装 Weinre 使用 NPM 全局安装 Weinre 1$ sudo npm -g install weinre 2、启动 Weinre 监听服务 12$ ipconfig getifaddr en0 // 查看本机 IP$ weinre --boundHost 10.14.217.14 --httpPort 8090 --boundHost 后填入你本机 IP 地址，--httpPort 后填入端口号，默认为 8080 3、进入 Weinre 管理页面 使用 Chrome 浏览器访问 http://10.14.217.14:8090，在管理页面你可以看到使用相关的说明，有进入客户端调试界面的地址、使用的文档、DEMO 页面等等，说明中要求将一段 JS 脚本 &lt;script src=&quot;http://10.14.217.14:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; 插入到需要调试的页面中，插入代码后手机访问调试页面。 4、进入客户端调试界面 点击 debug client user interface：http://10.14.217.14:8090/client/#anonymous 的链接。 5、JS 脚本注入 手动加入 JS 脚本不优雅，这里可以结合我们前面提到的 Charles 代理工具实现动态 HTTP Script 注入。 打开菜单 -&gt; Rewrite -&gt; 勾选 Enable Rewrite 输入 Rewrite 的名字并且在 Rules 一项添加匹配的规则，Location 一项是用于指定的域名和端口添加规则用的，这里我们不填默认匹配所有请求。 Type 允许对需要匹配的请求进行 Rewrite，一共提供了 11 种： Add Header Modify Header Remove Header Host Path URL Add Query Param Modify Query Param Remove Query Param Response Status Body 这里我们需要使用到的是 Body，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 &lt;/body&gt; 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。 另外，也有基于 Weinre 进行功能扩展的工具，比如早期版本的 微信 Web 开发者工具 v0.7.0 和 spy-debugger，都在 Weinre 的基础上简化了要给每个调试页面添加 JS 脚本的步骤，spy-debugger 还增加了对 HTTPS 的支持。 感谢你的阅读，如果你还有其他更为实用的调试方案，欢迎下方留言交流。 参考资料 Safari Web Inspector Guide Get Started with Remote Debugging Android Devices Remote Debugging WebViews weinre - Running Charles Web Debugging Proxy wuchangming/spy-debugger TBS 开发调试利器 —— TBS Studio - QQ 浏览器移动产品论坛 微信 web 开发者工具","pubDate":"Fri, 24 Feb 2017 06:45:36 GMT","guid":"https://aotu.io/notes/2017/02/24/Mobile-debug/","category":"Web开发"},{"title":"“等一下，我碰！”——常见的2D碰撞检测","link":"https://aotu.io/notes/2017/02/16/2d-collision-detection/","description":"“碰乜鬼嘢啊，碰走晒我滴靓牌”。想到“碰”就自然联想到了“麻将”这一伟大发明。当然除了“碰”，洗牌的时候也充满了各种『碰撞』。 好了，不废话。直入主题——碰撞检测。 在 2D 环境下，常见的碰撞检测方法如下： 外接图形判别法 轴对称包围盒（Axis-Aligned Bounding Box），即无旋转矩形。 圆形碰撞 圆形与矩形（无旋转） 圆形与旋转矩形（以矩形中心点为旋转轴） 光线投射法 分离轴定理 其他 地图格子划分 像素检测 下文将由易到难的顺序介绍上述各种碰撞检测方法：外接图形判别法 &gt; 其他 &gt; 光线投射法 &gt; 分离轴定理。 另外，有一些场景只要我们约定好限定条件，也能实现我们想要的碰撞，如下面的碰壁反弹： See the Pen Boundary collision detection by Jc (@JChehe) on CodePen. 当球碰到边框就反弹(如x/y轴方向速度取反)。 12if(ball.left &lt; 0 || ball.right &gt; rect.width) ball.velocityX = -ball.velocityXif(ball.top &lt; 0 || ball.bottom &gt; rect.height) ball.velocityY = -ball.velocityY 再例如当一个人走到 100px 位置时不进行跳跃，就会碰到石头等等。 因此，某些场景只需通过设定到适当的参数即可实现碰撞检测。 外接图形判别法轴对称包围盒（Axis-Aligned Bounding Box）概念：判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。 算法： 1234rect1.x &lt; rect2.x + rect2.width &amp;&amp;rect1.x + rect1.width &gt; rect2.x &amp;&amp;rect1.y &lt; rect2.y + rect2.height &amp;&amp;rect1.height + rect1.y &gt; rect2.y 两矩形间碰撞的各种情况： 在线运行示例（先点击运行示例以获取焦点，下同）： See the Pen AxisAlignedBoundingBox collision detection by Jc (@JChehe) on CodePen. 缺点： 相对局限：两物体必须是矩形，且均不允许旋转（即关于水平和垂直方向上对称）。 对于包含着图案（非填满整个矩形）的矩形进行碰撞检测，可能存在精度不足的问题。 物体运动速度过快时，可能会在相邻两动画帧之间快速穿越，导致忽略了本应碰撞的事件发生。 适用案例： （类）矩形物体间的碰撞。 圆形碰撞（Circle Collision）概念：通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。 两点之间的距离由以下公式可得： 判断两圆心距离是否小于两半径之和： 123Math.sqrt(Math.pow(circleA.x - circleB.x, 2) + Math.pow(circleA.y - circleB.y, 2)) &lt; circleA.radius + circleB.radius 图例： 在线运行示例： See the Pen EZrorG by Jc (@JChehe) on CodePen. 缺点： 与『轴对称包围盒』类似 适用案例： （类）圆形的物体，如各种球类碰撞。 圆形与矩形（无旋转）概念：通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。 那如何找出矩形上离圆心最近的点呢？下面我们从 x 轴、y 轴两个方向分别进行寻找。为了方便描述，我们先约定以下变量： 123矩形上离圆心最近的点为变量：closestPoint = &#123;x, y&#125;;矩形 rect = &#123;x, y, w, h&#125;; // 左上角与宽高圆形 circle = &#123;x, y, r&#125;; // 圆心与半径 首先是 x 轴： 如果圆心在矩形的左侧（if(circle.x &lt; rect.x)），那么 closestPoint.x = rect.x。 如果圆心在矩形的右侧（else if(circle.x &gt; rect.x + rect.w)），那么 closestPoint.x = rect.x + rect.w。 如果圆心在矩形的正上下方（else），那么 closestPoint.x = circle.x。 同理，对于 y 轴（此处不列举图例）： 如果圆心在矩形的上方（if(circle.y &lt; rect.y)），那么 closestPoint.y = rect.y。 如果圆心在矩形的下方（else if(circle.y &lt; rect.y + rect.h)），那么 closestPoint.y = rect.y + rect.h。 圆形圆心在矩形的正左右两侧（else），那么 closestPoint.y = circle.y。 因此，通过上述方法即可找出矩形上离圆心最近的点了，然后通过『两点之间的距离公式』得出『最近点』与『圆心』的距离，最后将其与圆的半径相比，即可判断是否发生碰撞。 1234var distance = Math.sqrt(Math.pow(closestPoint.x - circle.x, 2) + Math.pow(closestPoint.y - circle.y, 2))if(distance &lt; circle.r) return true // 发生碰撞else return false // 未发生碰撞 在线运行示例： See the Pen Circle and Rectangle by Jc (@JChehe) on CodePen. 缺点： 矩形需是轴对称的，即不能旋转。 圆形与旋转矩形（以矩形中心为旋转轴）概念：即使矩形以其中心为旋转轴进行了旋转，但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点。 对于旋转后的矩形，要找出其离圆心最近的点，视乎有些困难。其实，我们可以将我们思想的范围进行扩大：将矩形的旋转看作是整个画布的旋转。那么我们将画布（即 Canvas）反向旋转『矩形旋转的角度』后，所看到的结果就是上一个方法“圆形与矩形（无旋转）”的情形。因此，我们只需求出画布旋转后的圆心位置，即可使用『圆形与矩形（无旋转）』的判断方法了。 先给出可直接套用的公式，从而得出旋转后的圆心坐标：12x’ = cos(β) * (cx – centerX) – sin(β) * (cy – centerY) + centerXy’ = sin(β) * (cx – centerX) + cos(β) * (cy – centerY) + centerY 下面给出该公式的推导过程： 根据下图，计算某个点绕另外一个点旋转一定角度后的坐标。我们设 A(x,y) 绕 B(a,b) 旋转 β 度后的位置为 C(c,d)。 设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β) 由于 |AB| 与 |CB| 相等（即长度），且 |AB| = y/sin(δ) = x / cos(δ) |CB| = d/sin(δ + β) = c / cos(δ + β) 半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β) 由以下三角函数两角和差公式： sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β) cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β) 可得出旋转后的坐标： c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β) d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β) 由上述公式推导后可得：旋转后的坐标 (c,d) 只与旋转前的坐标 (x,y) 及旋转的角度 β 有关。 当然，(c,d) 是旋转一定角度后『相对于旋转点（轴）的坐标』。因此，前面提到的『可直接套用的公式』中加上了矩形的中心点的坐标值。 从图中也可以得出以下结论：A 点旋转后的 C 点总是在圆周（半径为 |AB|）上运动，利用这点可让物体绕旋转点（轴）做圆周运动。 得到旋转后的圆心坐标值后，即可使用『圆形与矩形（无旋转）』方法进行碰撞检测了。 在线运行案例： See the Pen Circle and Rotated Rectangle Collision Detection by Jc (@JChehe) on CodePen. 优点： 相对于圆形与矩形（未旋转）的方法，适用范围更广。 其他地图格子划分概念：将地图（场景）划分为一个个格子。地图中参与检测的对象都存储着自身所在格子的坐标，那么你即可以认为两个物体在相邻格子时为碰撞，又或者两个物体在同一格才为碰撞。另外，采用此方式的前提是：地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍。 蓝色X 为障碍物： 实现方法： 12345678910111213// 通过特定标识指定（非）可行区域map = [ [0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0]],// 设定角色的初始位置player = &#123;left: 2, top: 2&#125;// 移动前（后）判断角色的下一步的动作（如不能前行）... 在线运行示例： See the Pen map cell collision detection by Jc (@JChehe) on CodePen. 缺点： 适用场景局限。 适用案例： 推箱子、踩地雷等 像素检测概念：以像素级别检测物体之间是否存在重叠，从而判断是否碰撞。 实现方法有多种，下面列举在 Canvas 中的两种实现方式： 如下述的案例中，通过将两个物体在 offscreen canvas 中判断同一位置（坐标）下是否同时存在非透明的像素。 利用 canvas 的 globalCompositeOperation = &#39;destination-in&#39; 属性。该属性会让两者的重叠部分会被保留，其余区域都变成透明。因此，若存在非透明像素，则为碰撞。 注意，当待检测碰撞物体为两个时，第一种方法需要两个 offscreen canvas，而第二种只需一个。 offscreen canvas：与之相关的是 offscreen rendering。正如其名，它会在某个地方进行渲染，但不是屏幕。“某个地方”其实是内存。渲染到内存比渲染到屏幕更快。—— Offscreen Rendering 当然，我们这里并不是利用 offscreen render 的性能优势，而是利用 offscreen canvas 保存独立物体的像素。换句话说：onscreen canvas 只是起展示作用，碰撞检测是在 offscreen canvas 中进行。 另外，由于需要逐像素检测，若对整个 Canvas 内所有像素都进行此操作，无疑会浪费很多资源。因此，我们可以先通过运算得到两者相交区域，然后只对该区域内的像素进行检测即可。 图例： 下面示例展示了第一种实现方式： See the Pen pixel collision detection by Jc (@JChehe) on CodePen. 缺点： 因为需要检查每一像素来判定是否碰撞，性能要求比较高。 适用案例： 需要以像素级别检测物体是否碰撞。 光线投射法（Ray Casting）概念：通过检测两个物体的速度矢量是否存在交点，且该交点满足一定条件。 对于下述抛小球入桶的案例：画一条与物体的速度向量相重合的线(#1)，然后再从另一个待检测物体出发，连线到前一个物体，绘制第二条线(#2)，根据两条线的交点位置来判定是否发生碰撞。 抛球进桶图例： 在小球飞行的过程中，需要不断计算两直线的交点。 当满足以下两个条件时，那么应用程序就可以判定小球已落入桶中： 两直线交点在桶口的左右边沿间 小球位于第二条线（#2）下方 在线运行示例： See the Pen ray casting collision detection by Jc (@JChehe) on CodePen. 优点： 适合运动速度快的物体 缺点： 适用范围相对局限。 适用案例： 抛球运动进桶。 分离轴定理（Separating Axis Theorem）概念：通过判断任意两个 凸多边形 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 图例： 在程序中，遍历所有角度是不现实的。那如何确定 投影轴 呢？其实投影轴的数量与多边形的边数相等即可。 以较高抽象层次判断两个凸多边形是否碰撞： 123456789101112131415161718function polygonsCollide(polygon1, polygon2) &#123; var axes, projection1, projection2 // 根据多边形获取所有投影轴 axes = polygon1.getAxes() axes.push(polygon2.getAxes()) // 遍历所有投影轴，获取多边形在每条投影轴上的投影 for(each axis in axes) &#123; projection1 = polygon1.project(axis) projection2 = polygon2.project(axis) // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。 if(!projection1.overlaps(projection2)) return false &#125; return true&#125; 上述代码有几个需要解决的地方： 如何确定多边形的各个投影轴 如何将多边形投射到某条投影轴上 如何检测两段投影是否发生重叠 投影轴如下图所示，我们使用一条从 p1 指向 p2 的向量来表示多边形的某条边，我们称之为边缘向量。在分离轴定理中，还需要确定一条垂直于边缘向量的法向量，我们称之为“边缘法向量”。 投影轴平行于边缘法向量。投影轴的位置不限，因为其长度是无限的，故而多边形在该轴上的投影是一样的。该轴的方向才是关键的。 12345678// 以原点(0,0)为始，顶点为末。最后通过向量减法得到 边缘向量。var v1 = new Vector(p1.x, p1.y) v2 = new Vector(p2.x, p2.y)// 首先得到边缘向量，然后再通过边缘向量获得相应边缘法向量（单位向量）。// 两向量相减得到边缘向量 p2p1（注：上面应该有个右箭头，以表示向量）。// 设向量 p2p1 为(A,B)，那么其法向量通过 x1x2+y1y2 = 0 可得：(-B,A) 或 (B,-A)。 axis = v1.edge(v2).normal() 以下是向量对象的部分实现，具体可看源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Vector = function(x, y) &#123; this.x = x this.y = y&#125;Vector.prototype = &#123; // 获取向量大小（即向量的模），即两点间距离 getMagnitude: function() &#123; return Math.sqrt(Math.pow(this.x, 2), Math.pow(this.y, 2)) &#125;, // 点积的几何意义之一是：一个向量在平行于另一个向量方向上的投影的数值乘积。 // 后续将会用其计算出投影的长度 dotProduct: function(vector) &#123; return this.x * vector.x + this.y + vector.y &#125;, // 向量相减 得到边 subtarct: function(vector) &#123; var v = new Vector() v.x = this.x - vector.x v.y = this.y - vector.y return v &#125;, edge: function(vector) &#123; return this.substract(vector) &#125;, // 获取当前向量的法向量（垂直） perpendicular: function() &#123; var v = new Vector() v.x = this.y v.y = 0 - this.x return v &#125;, // 获取单位向量（即向量大小为1，用于表示向量方向），一个非零向量除以它的模即可得到单位向量 normalize: function() &#123; var v = new Vector(0, 0) m = this.getMagnitude() if(m !== 0) &#123; v.x = this.x / m v.y = this.y /m &#125; return v &#125;, // 获取边缘法向量的单位向量，即投影轴 normal: function() &#123; var p = this.perpendicular() return p .normalize() &#125;&#125; 向量相减 更多关于向量的知识可通过其它渠道学习。 投影投影的大小：通过将一个多边形上的每个顶点与原点(0,0)组成的向量，投影在某一投影轴上，然后保留该多边形在该投影轴上所有投影中的最大值和最小值，这样即可表示一个多边形在某投影轴上的投影了。 判断两多边形的投影是否重合：projection1.max &gt; projection2.min &amp;&amp; project2.max &gt; projection.min 为了易于理解，示例图将坐标轴原点(0,0)放置于三角形边1投影轴的适当位置。 由上述可得投影对象： 123456789101112// 用最大和最小值表示某一凸多边形在某一投影轴上的投影位置var Projection = function (min, max) &#123; this.min this.max&#125;projection.prototype = &#123; // 判断两投影是否重叠 overlaps: function(projection) &#123; return this.max &gt; projection.min &amp;&amp; projection.max &gt; this.min &#125;&#125; 如何得到向量在投影轴上的长度？向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2 123456789101112// 根据多边形的每个定点，得到投影的最大和最小值，以表示投影。function project = function (axis) &#123; var scalars = [], v = new Vector() this.points.forEach(function (point) &#123; v.x = point.x v.y = point.y scalars.push(v.dotProduct(axis)) &#125;) return new Projection(Math.min.apply(Math, scalars), Math.max,apply(Math, scalars))&#125; 圆形与多边形之间的碰撞检测由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示： 因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。 而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。 分离轴定理的整体代码实现，可查看以下案例： See the Pen SeparatingAxisTheorem by Jc (@JChehe) on CodePen. 优点： 精确 缺点： 不适用于凹多边形 适用案例： 任意凸多边形和圆形。 更多关于分离轴定理的资料： Separating Axis Theorem (SAT) explanation Collision detection and response Collision detection Using the Separating Axis Theorem SAT (Separating Axis Theorem) Separation of Axis Theorem (SAT) for Collision Detection 延伸：最小平移向量（MIT）通常来说，如果碰撞之后，相撞的双方依然存在，那么就需要将两者分开。分开之后，可以使原来相撞的两物体彼此弹开，也可以让他们黏在一起，还可以根据具体需要来实现其他行为。不过首先要做的是，还是将两者分开，这就需要用到最小平移向量（Minimum Translation Vector, MIT）。 碰撞性能优化若每个周期都需要对全部物体进行两两判断，会造成浪费（因为有些物体分布在不同区域，根本不会发生碰撞）。所以，大部分游戏都会将碰撞分为两个阶段：粗略和精细（broad/narrow）。 粗略阶段（Broad Phase）Broad phase 能为你提供有可能碰撞的实体列表。这可通过一些特殊的数据结构实现，它们能为你提供信息：实体存在哪里和哪些实体在其周围。这些数据结构可以是：四叉树（Quad Trees）、R树（R-Trees）或空间哈希映射（Spatial Hashmap）等。 读者若感兴趣，可以自行查阅相关信息。 精细阶段（Narrow Phase）当你有了较小的实体列表，你可以利用精细阶段的算法（如上述讲述的碰撞算法）得到一个确切的答案（是否发生碰撞）。 最后碰撞检测有多种，选择合适最重要。 完！ 参考资料 MDN：2D collision detection 《HTML5 Canvas 核心技术：图形、动画与游戏开发》 Circular Collision Detection Circle and Rotated Rectangle Collision Detection 推导坐标旋转公式","pubDate":"Thu, 16 Feb 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/02/16/2d-collision-detection/","category":"Web开发"},{"title":"探讨判断横竖屏的最佳实现","link":"https://aotu.io/notes/2017/01/31/detect-orientation/","description":"在移动端，判断横竖屏的场景并不少见，比如根据横竖屏以不同的样式来适配，抑或是提醒用户切换为竖屏以保持良好的用户体验。判断横竖屏的实现方法多种多样，本文就此来探讨下目前有哪些实现方法以及其中的优缺点。 CSS Media Queries通过媒体查询的方式，我们可以通过以下方法来实现根据横竖屏不同的情况来适配样式： 1.内联样式1234567@media screen and (orientation:portrait) &#123; //竖屏&#125;@media screen and (orientation:landscape) &#123; //横屏&#125; 2.外联样式12345&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"...\" /&gt;&lt;!-- 横屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"...\" /&gt; window.matchMedia()除此之外，CSS Object Model（CSSOM）Views 规范增加了对 JavaScript 操作 CSS Media Queries 的原生支持，它在 window 对象下增加了 matchMedia() 方法，让我们能够通过脚本的方式来实现媒体查询。 window.matchMedia() 方法接受一个 Media Queries 语句的字符串作为参数，返回一个 MediaQueryList 对象。该对象有 media 和 matches 两个属性： media：返回所查询的 Media Queries 语句字符串 matches：返回一个布尔值，表示当前环境是否匹配查询语句 同时，它还包含了两个方法，用来监听事件： addListener(callback)：绑定回调 callback 函数 removeListener(callback)：注销回调 callback 函数 那么，通过 window.matchMedia() 的方法，我们可以这样判断横竖屏： 12345678910var mql = window.matchMedia(\"(orientation: portrait)\");function onMatchMeidaChange(mql)&#123; if(mql.matches) &#123; // 竖屏 &#125;else &#123; // 横屏 &#125;&#125;onMatchMeidaChange(mql);mql.addListener(onMatchMeidaChange); 通过Can I Use - matchMeida可以知道，该API在移动端得到良好的支持，并无兼容性问题。 window.innerHeight/window.innerWidth The ‘orientation’ media feature is ‘portrait’ when the value of the ‘height’ media feature is greater than or equal to the value of the ‘width’ media feature. Otherwise ‘orientation’ is ‘landscape’.—— CSS/Mediaqueries/orientation 在 CSS Media Queries 中，Orientation 属性有两个值： portrait，指的是当 height 大于等于 width 的情况 landscape，指的是当 height 小于 width 的情况 所以，还有一种最为常见的方法是通过比较页面的宽高，当页面的高大于等于宽时则认为是竖屏，反之则为横屏。 123456789function detectOrient()&#123; if(window.innerHeight &gt;= window.innerWidth) &#123; // 竖屏 &#125;else &#123; // 横屏 &#125;&#125;detectOrient();window.addEventListener('resize',detectOrient); window.orientation在 iOS 平台以及大部分 Android 手机都有支持 window.orientation 这个属性，它返回一个与默认屏幕方向偏离的角度值： 0：代表此时是默认屏幕方向 90：代表顺时针偏离默认屏幕方向90度 -90：代表逆时针偏离默认屏幕方向90度 180：代表偏离默认屏幕方向180度 在 iOS 的开发者文档（iOS Developer Library - Handling Orientation Events）是这样明确定义的： 1234567891011121314151617switch(window.orientation) &#123; case 0: displayStr += \"Portrait\"; break; case -90: displayStr += \"Landscape (right, screen turned clockwise)\"; break; case 90: displayStr += \"Landscape (left, screen turned counterclockwise)\"; break; case 180: displayStr += \"Portrait (upside-down portrait)\"; break;&#125; 也就是如下图所示： （图来自William Malone - DETECT IOS DEVICE ORIENTATION WITH JAVASCRIPT） 在实际应用中，对于 iPhone 和大部分 Android 是没有180度的手机竖屏翻转的情况的，但是 iPad 是存在的。所以，简化下代码，我们可以绑定orientationchange事件来判断横竖屏： 123456789function detectOrient()&#123; if (Math.abs(window.orientation) === 90) &#123; // 横屏 &#125; else &#123; // 竖屏 &#125;&#125;detectOrient();window.addEventListener('orientationchange',detectOrient); 影响判断的问题所在1.对window.orientation属性值的不一致在 iOS 平台，对 window.orientation 属性值是无异议的，规范当中有明确规定每个值对应的情况。但是对于 Android 平台，就有不一致的特殊情况出现。 A misconception about window.orientation中作者 Matthew Gifford 就有提到部分 Android 机型(该文章中测试用的 Toshiba Thrive 机型)返回的情况是与期望情况是相反的；除此之外，在 StackOverflow 上也有反馈过这样的问题（例如，window.orientation returns different values in iOS and Android中提到的 Samsung Tab 2 机型）。 其实，Matthew Gifford 认为这并不是 BUG（笔者也认同），按照Compatibility Standard - 4.2 window.orientation API规范中的定义，0 值指的是 natural 、 default 的屏幕方向，所以如果生厂商对 natural 、 default 状态是用户应当手持设备方向为横屏，那么 0 值对应为 landscape 的横屏方向了。针对这种不一致情况的出现，对于追求完美的开发者来说，通过 window.orientation 的方法来判断横竖屏则变得有点不可靠的。 2.软键盘的弹出是否除了 window.orientation 的其它方法都是可靠的呢？然而，实际上是事与愿违的。在 Android 下，如果页面中出现软键盘弹出的情况（存在有 Input 的元素）时，页面有时会因为软键盘的弹出而导致页面回缩，即页面的宽度（竖屏时）或者高度（横屏时）被改变。无论是 CSS Media Queries 还是 window.matchMedia() 方法，还是根据 window.innerWidth 、window.innerHeight的页面宽高比对方法来实现的横竖屏判断方法，都会因此受到影响，出现判断失误的情况（ Samsung SCH-i699 机型，在竖屏时由于软键盘弹出导致页面高度小于宽度，被错误地判定为横屏）。所以，在这样的情况下，这几种方式也变得不可靠。 探讨最佳实现方式本着核心的原则——具体情况具体解决来讨论。 如果你没有遇上以上两个问题所在，恭喜你！上面所提到的方法都可以被应用，选择你最为喜欢的方法就好。 但是如果想要避免以上两个问题所在，有没有更好的办法呢？ 经过实际情况的研究，针对开发环境兼容的情况（ iOS 与 Android 下的微信内置浏览器与原生浏览器）来说，屏幕分辨率是不会改变的，那么我们可以尝试比对页面宽高和屏幕分辨率来判断横竖屏。 需要注意的是，微信内置浏览器页面宽度不包括顶栏部分的，而 Android 和 iOS 的原生浏览器都是带有底栏或顶栏兼有的，如下图所示。 （图为 iPhone 6s 下的微信内置浏览器与原生浏览器截图） 那么，我们可以确定为： 假如屏幕分辨率固定值为：screen.width 和 screen.height（需要注意，这里很重要的一点是：在移动端，屏幕翻转时，screen.width 和 screen.height 的值依然是不变的后面有补充修正，可以直接跳到下一个章节阅读） 若获取 当前页面的宽（document.documentElement.clientWidth），等于屏幕分辨率的宽(screen.width)，则可认定当前属于竖屏。 （图为以 iPhone 6s 竖屏下的微信内置浏览器为例的截图） 若获取 当前页面的宽（document.documentElement.clientWidth），等于屏幕分辨率的高(screen.height)，则可认定当前属于横屏。 （图为以 iPhone 6s 横屏下的微信内置浏览器为例的截图） 如此，对应的代码为： 1234567891011121314151617181920212223242526272829function detectOrient() &#123; var storage = localStorage; var data = storage.getItem('J-recordOrientX'); var w = document.documentElement.clientWidth, h = document.documentElement.clientHeight; var _Width = 0, _Height = 0; if(!data) &#123; _Width = window.screen.width; _Height = window.screen.height; storage.setItem('J-recordOrientX',_Width + ',' + _Height); &#125;else &#123; var str = data.split(','); _Width = str[0]; _Height = str[1]; &#125; if(w == _Width) &#123; // 竖屏 return; &#125; if(w == _Height)&#123; // 横屏 return; &#125;&#125;detectOrient();window.addEventListener('resize',detectOrient); 以上是笔者拙劣的见解，如果你有更好的办法解决，欢迎来分享！ 今后的发展目前，W3C 引入Screen Orientation API，该标准能够帮助 Web 应用获得屏幕方向的状态，在状态改变时获得通知，并能够从应用程序中将屏幕状态锁定到特定状态。但截止目前，该标准仍在 W3C 草案阶段。在移动端，它在 Android 和 iOS 平台上仍未得到支持，仅仅在 Chrome for Android 39 版本及以上才得到实现，所以对目前的开发来说意义不大。只能期待它能够尽快通过并得到广泛支持，这样的检测屏幕方向的问题就能够得到规范化的解决。 20170425更新感谢各位读者的反馈，笔者的自测确实是没有覆盖全面，有些读者反馈的以下几点问题确实存在：1.在 华为P9 的微信（6.5.4）、华为荣耀的微信（6.5.7）和 Chrome 浏览器上，screen.width 与 screen.height 均会随着横竖屏的切换而变。2.另外，笔者也发现在移动端还有一点很重要的点会影响到 document.documentElement.clientWidth/clientHeight 的值 —— Meta Viewport的设置。3.在微信内（其他移动浏览器也会），会多次触发resize事件。 然而，以上三个问题都是不影响本文所提出的方法的核心思想，而只需要将方法进行bug的修正即可。这里先丢出体验地址，其中，修正后的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 判断横竖屏var utils = &#123; debounce: function(func,delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; func.apply(context,args); &#125;,delay); &#125; &#125;&#125;var detectRes = document.getElementById('J_detectRes');var detectData = document.getElementById('J_detectData');function detectOrient() &#123; var storage = localStorage; // 不一定要使用localStorage，其他存储数据的手段都可以 var data = storage.getItem('J-recordOrientX'); var cw = document.documentElement.clientWidth; var _Width = 0, _Height = 0; if(!data) &#123; sw = window.screen.width; sh = window.screen.height; // 2.在某些机型（如华为P9）下出现 srceen.width/height 值交换，所以进行大小值比较判断 _Width = sw &lt; sh ? sw : sh; _Height = sw &gt;= sh ? sw : sh; storage.setItem('J-recordOrientX',_Width + ',' + _Height); &#125;else &#123; var str = data.split(','); _Width = str[0]; _Height = str[1]; &#125; if(cw == _Width) &#123; // 竖屏 return; &#125; if(cw == _Height)&#123; // 横屏 return; &#125;&#125;// 3.函数去抖处理window.onresize = utils.debounce(detectOrient,300);detectOrient(); 然后，下面则讲诉如何针对性逐一突破。 1.横竖屏切换时，screen.width与screen.height的值可能会改变随着横竖屏幕的切换，screen.width与screen.height在大部分机型上会维持不变，而在一些机型上如@Jc、@百思不得姐夫提出的华为 P9 微信内置浏览器(6.5.4版本)、Chrome桌面端浏览器模拟器中会出现值交换的现象。 例如，在Chome上 iPhone 6 模拟器中，竖屏时screen.width与screen.height等于375px、667px，而横屏时，sreen.width与screen.height等于 667px 、 375px，两者属性值出现了值交换现象。 这个问题很容易解决，虽然出现了值交换，但是值大小还是不变的，那么我们可以先通过比较大小来判断出属性值较小的是screen.width，而属性值较大的是screen.height，然后再用来与document.documentElement.clientWidth/clientHeight进行比较，从而判断出横竖屏。 2.Meta Viewport的设置会影响document.documentElement.clientWidth/clientHeightPeter-Paul Koch 的《两个 Viewport 的故事》的一文中提出的关于 Viewport 的理论被认为是业界的主流论调，它指出 Layout Viewport 的尺寸可以通过document.documentElement.clientWidth/clientHeight进行度量。而通过设置 Meta Viewport （也就是 viewport meta 标签）是可以改变 Layout Viewport 的尺寸。 所以，Meta Viewport的属性设置如何是会影响到document.documentElement.clientWidth/clientHeight的值，这就是一部分读者迷惑到”为什么会我测量document.documentElement.clientWidth/clientHeight的值与screen.width/height的值不相同？“的原因所在。 因此，在这里也补充一点，在笔者提出的方法中，有个忘记跟大家说明的前提——页面设置了以下属性以保证页面的适配： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\" /&gt; 这句语句的设置就保证了页面是始终适配屏幕的，在横竖屏切换的场景中document.documentElement.clientWidth/clientHeight必然与screen.width/height其中一值相等，并且这也是本文提出的横竖屏检测方法的核心。 3.resize事件的多次触发笔者是通过绑定监听resize事件来响应执行横竖屏检测方法的，而在实际应用中确实出现了resize事件触发两次的情况。 虽然并没有影响到事件的判断结果，但是这也算个值得优化的点，而且问题也不大，我们只要通过函数去抖（ Debounce Function ) 办法来进行简单的解决就好。 123456789101112131415// 函数去抖的简单封装var utils = &#123; debounce: function(func,delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; func.apply(context,args); &#125;,delay); &#125; &#125;, ...&#125; 参考文档 A misconception about window.orientation Trouble with web browser orientation Compatibility Standard - 4.2 window.orientation API","pubDate":"Tue, 31 Jan 2017 01:27:00 GMT","guid":"https://aotu.io/notes/2017/01/31/detect-orientation/","category":"Web开发"},{"title":"使用 Snap.svg 制作动画","link":"https://aotu.io/notes/2017/01/22/snapsvg/","description":"一、Snap.svg是什么从主要功能上说，Snap.svg.js 是一个操纵 SVG 节点/制作 SVG 动画的框架，简单点理解可以看下面文字： Snap.svg 是一个可以使你操纵 SVG 资源和 jQuery 操作 DOM 一样简单的类库 ——译自官网 拿 Snap.svg (下文简称 Snap ) 和 jQuery (下文简称 JQ ) 来做对比最合适不过，很可能作者也是参考了 JQ 的 API 设计，那么它们的相似程度有多高呢？请看下面的对比表： / context(上下文) 选择器 事件绑定 节点操作 属性操作 链式写法 Snap svg Snap.select(‘circle’) el.click(…)/el.touchend(…) after()/remove()/append() attr() svg.paper.circle(50,50,40).attr({fill:”#f00”}); JQ document jQuery(‘div’) el.click(…) after()/remove()/append() attr() elem.addClass(‘hide’).remove(); 在 JQ 中，可操作的最外层 DOM 边界是 document 。而在 Snap 的概念里，可操作的最外层的节点是 svg ，svg 节点的选择、事件绑定都需要在这个上下文里完成。 在上面的对比图可以看出很多 JQ 的影子，无论是选择器、事件绑定、节点操作等等，都是非常的类似 JQ ，有 JQ 基础的同学基本可以半天掌握 Snap 的全部 API。 二、Snap 的代码结构 笔者根据 Snap 的 API 制作了上面的图表，并且简单标注了注释方便大家理解，可以重点关注一下 Element 和 Paper 这两个类。 1. Element这个部分是节点操作相关的方法集，也是该类库最基础的部分。 1234// 选择节点var svg = Snap('#svg');svg.select('circle'); // 选择svg.select('.rect_01'); // 选择 12345// 事件绑定var svg = Snap('#svg');svg.select('circle').click(function() &#123; // do something&#125;); 更多方法请参考文后 API 资料。 2. Paper这部分是画图相关的方法集，这是几乎每个动画框架都有的部分，类似于createjs的Graphics。 SVG 有6种基本图形：矩形、圆形 、椭圆、线条、折线、多边形。还有另外一种：路径(path)，path 是最复杂的一种绘图方式，它可以绘制复杂的图形——当然6种基本图形也不在话下。而关于基本图像与 path 之间的转换，可以参考本站的另外一篇文章：聊聊 SVG 基本形状转换那些事。 Paper 方法集主要可以绘制6种基本图形（节点），以及文本（节点）、图片（节点）、渐变等。 1234567891011// 画一个圆var svg = Snap('#svg');svg.paper.circle(&#123; cx: 100, cy: 100, r: 50, fill: '#f00'&#125;);// 创建一张图片svg.paper.image('url.jpg', 0, 400, 300, 300); 3. Snap 工具方法Snap下有不少实用工具，比如 Snap.ajax、Snap.format模板、颜色格式转换和插件方法等。 123456// 扩展Snap，为其添加插件方法Snap.plugin(function (Snap, Element, Paper, global, Fragment) &#123; Snap.newmethod = function () &#123;&#125;; Element.prototype.newmethod = function () &#123;&#125;; Paper.prototype.newmethod = function () &#123;&#125;;&#125;); 三、用 Snap 制作动画1. 制作动画的方法Snap 的做动画主要有两种方式： 使用 Element 里的 animate 方法，Element.animate(attrs, duration, [easing], [callback]) 使用 Snap 的静态方法，Snap.animate(from, to, setter, duration, [easing], [callback])，这种方法更通用也更强大，指定开始结束值，setter里面可以放置多个节点的动画。 样例：演示Element.animate方法的使用。预览地址点此 12345678910111213141516// 动画样例1var svg = Snap('#svg');svg.select('circle').animate(&#123;r: 100&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;);// 动画样例2var svg = Snap('#svg');var circle = svg.select('circle');var rect = svg.select('rect');Snap.animate(0, 100, function(val) &#123; circle.attr(&#123;r: val&#125;); rect.attr(&#123;x: val&#125;);&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 2. 动画的属性在 Snap 中，可作为动画的属性有哪些呢？笔者大致分为了几类： 简单数值类，如坐标、宽高、opacity、大部分 Paper API 可配置的属性值，甚至滤镜相关的属性。如{x:100} -&gt; {x:200}, {width:0} -&gt; {width:100} path 相关动画，如d属性（变形动画）、描边动画、路径跟随动画 matrix 类，放大缩小、位移、旋转等，和 CSS 的 transform 类似 颜色类，颜色变换动画，如 fill、stroke 属性，如{fill:’#f00’} -&gt; {fill:’#f0f’} 样例：颜色变换动画，预览地址点此 123456// 动画样例，颜色变化动画var svg = Snap('#svg');var circle = svg.paper.circle(&#123;cx: 100, cy: 100, r: 50, fill: '#f00'&#125;);circle.animate(&#123;fill: '#00f'&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 四、path &amp; matrix 动画详解这个小节重点会讲上面第2小节提到的 path、matrix 相关动画方式，以及和 CSS 的 transform 动画的异同。 1. path 动画1). path 变形动画这种类型的动画非常强大。上文已提到基本图形和 path 是可以相互转换的，所以基本图形间的变形动画也是成立的。不仅如此，更复杂的 path 图形，比如波浪、房子、汽车、白云、小icon等，都是可以互相变形。 path 的d属性在 Snap 的解析规则里可以通过一系列的数学运算，动画中通过插值，达到最终态的d值，不过中间的插值计算我们无法干预。 123456789101112// 开始态var path = svg.paper.path(&#123;d: 'M0.500,65.500 C18.680,33.758 45.141,-6.797 72.500,2.500 C99.859,11.797 72.148,59.027 79.500,98.500 C86.852,137.973 117.668,128.914 138.500,59.500 C159.332,-9.914 246.500,59.500 246.500,59.500 C273.181,117.750 137.350,184.417 225.500,173.500 C351.137,157.940 155.369,160.617 162.500,86.500 C165.180,58.645 237.169,-2.418 283.500,2.500 C357.654,10.371 363.758,80.355 364.500,109.500',stroke:'#f00', fill: 'rgba(0,0,0,0)'&#125;);setTimeout(function() &#123; // 终止态：曲线变直 // path.animate(&#123;d: 'M1,100 L350,100'&#125;, 1000, mina.easeout(), function() &#123; // console.log('animation end'); // &#125;); // 终止态：心形 path.animate(&#123;d: 'M114.500,58.500 C106.230,58.751 23.907,-37.262 5.500,21.500 C-26.759,124.483 111.761,221.360 119.500,219.500 C154.464,211.096 201.234,149.580 220.500,104.500 C250.260,34.864 220.892,7.159 194.500,1.500 C160.455,-5.800 122.344,58.262 114.500,58.500 Z'&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end'); &#125;);&#125;, 1000); 样例：曲线变直线，预览地址点此 样例：曲线变心形，预览地址点此 2). path 描边动画这种动画主要用的是 svg 的 stroke-dasharray、stroke-dashoffset 属性，这中动画方式在本站的另外一篇文章有详细介绍，这里不再赘述：三看 SVG Web 动效 样例：简单曲线描边动画12345678910111213var path = svg.paper.path(&#123;d: 'M0.500,65.500 C18.680,33.758 45.141,-6.797 72.500,2.500 C99.859,11.797 72.148,59.027 79.500,98.500 C86.852,137.973 117.668,128.914 138.500,59.500 C159.332,-9.914 246.500,59.500 246.500,59.500 C273.181,117.750 137.350,184.417 225.500,173.500 C351.137,157.940 155.369,160.617 162.500,86.500 C165.180,58.645 237.169,-2.418 283.500,2.500 C357.654,10.371 363.758,80.355 364.500,109.500', stroke:'#f00', fill: 'rgba(0,0,0,0)'&#125;);var length = Snap.path.getTotalLength(path);path.attr(&#123; 'stroke-dashoffset': length, 'stroke-dasharray': length // 用Snap的API计算复杂的path长度&#125;);Snap.animate(length, 0, function(val) &#123; path.attr(&#123; 'stroke-dashoffset': val &#125;);&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 或者用CSS实现：12345678@keyframes demo4 &#123; 100% &#123; stroke-dashoffset: 0 &#125;&#125;.demo4 &#123; animation: demo4 1s ease-out infinite both;&#125; 样例：花纹描边。这是codepen上一个复杂的例子——复杂花纹的描边动画，预览地址点此： 3). path 路径跟随动画这种动画是指一个 svg 节点（基本图形、文本、图片等）沿着轨迹移动的动画，主要适用于模拟交通工具航行轨迹、粒子散开轨迹等。 这种动画的关键之处在于要知道 path 的长度与坐标之间的对应关系，Snap 提供了可供获取path的长度以及根据长度获取位置坐标的 API。结合上面的 Snap.animate 方法，路径跟随动画的制作会变得非常简单。 样例：跟随曲线运动的小飞机，预览地址点此： 12345678910var length = Snap.path.getTotalLength(path); // 获取path的长度Snap.animate(0, length, function(val) &#123; var point = Snap.path.getPointAtLength(path, val); // 根据path长度变化获取坐标 var m = new Snap.Matrix(); m.translate(point.x, point.y); m.rotate(point.alpha-90); // 使飞机总是朝着曲线方向。point.alpha：点的切线和水平线形成的夹角 plane.transform(m);&#125;, 30000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 样例：双12开场动画，这是笔者去年双12做的一个路径跟随动画效果，预览地址点此： 另外，用新的 CSS 属性 motion-path 也可以实现类似效果，但目前支持程度堪忧，只有 PC 的 chrome 以及 Opera、最新的X5内核手机浏览器 支持情况较好。 12345678910111213@keyframes demo5 &#123; 0% &#123; motion-offset: 0; &#125; 100% &#123; motion-offset: 100%; &#125;&#125;.demo5 &#123; motion-path: path(\"M221.712,180.442C237.176,177.728,279.348,178.094,261,152c-18.742-26.654-48.543-28.207-63-22-14.981,6.431-34.763,6.357-34,40s66.09,74.162,88,68,60.358-23.742,67-49,14.211-59.957-27-81S163.688,88.664,153,98c-7.828,6.838-32.045,22.952-32,64,0.039,35.491,7.878,62.872,14,78s52.737,39.557,73,41,58.638,16.552,105-7c44.249-22.478,75.073-94.409,55-164C349.768,46.792,217.142,54.519,200,55S104.613,66.128,78,111c-16.922,28.532-16.5,96.616,1,134,14.482,30.932,51.88,58.52,68,64,39.988,13.593,100.081,21.615,129,17\"); motion-rotation: auto 90deg; // 使飞机方向始终朝着曲线 animation: demo5 10s linear infinite both;&#125; 预览地址点此（请在最新版 chrome、Opera 或最新的X5内核手机浏览器查看） 2. matrix动画Snap 的 matrix 动画包含各位熟悉的 translate/scale/rotate/skew 动画，原理和 CSS 的 transform 也几乎一致。 1) matrix简单位移动画，预览地址点此： 12345678910111213// 简单位移动画var rect = svg.paper.rect(&#123;x: 100, y: 100, width: 50, height: 30, fill: '#f00'&#125;);var anim = function() &#123; Snap.animate(0, 150, function(val) &#123; var m = new Snap.Matrix(); m.translate(val, 0); // translate位移API rect.transform(m); // 在rect节点应用matrix &#125;, 1000, mina.easeout(), function() &#123; console.log('animation end'); setTimeout(anim, 300); &#125;);&#125;anim(); 2) matrix位移、旋转复合动画，预览地址点此： 12345678910111213141516171819202122232425// 位移、旋转复合动画var rect = svg.paper.rect(&#123;x: 10, y: 100, width: 50, height: 30, fill: '#f00'&#125;);var g = svg.paper.group(rect); // 创建了一个分组节点g作为位移动画节点var anim_rotate = function() &#123; // 节点旋转部分 Snap.animate(0, 250, function(val) &#123; var m = new Snap.Matrix(); m.rotate((val/250)*360, 10+25, 100+15); // 注意，后面两位数是旋转中心点，属于绝对坐标，svg里节点的变换中心都是绝对坐标，和CSS的transform-origin取值不太一样 rect.transform(m); &#125;, 500, mina.easeout(), function() &#123; console.log('animation end'); anim_rotate(); &#125;);&#125;;anim_rotate();var anim_move = function() &#123; // 节点位移部分 Snap.animate(0, 250, function(val) &#123; var m = new Snap.Matrix(); m.translate(val, 0); g.transform(m); &#125;, 2000, mina.easeout(), function() &#123; console.log('animation end'); anim_move(); &#125;);&#125;;anim_move(); 上面两个动画用 CSS 的方式实现代码如下：12345678910111213141516171819202122232425262728@keyframes demo6 &#123; 100% &#123; transform: translate3d(250px, 0, 0); &#125;&#125;// 简单位移动画CSS版.demo6 &#123; animation: demo6 2s linear infinite both;&#125;@keyframes demo7_rotate &#123; 100% &#123; transform: rotate(360deg); &#125;&#125;@keyframes demo7_move &#123; 100% &#123; transform: translate3d(250px, 0, 0); &#125;&#125;// 旋转、位移符合动画CSS版.demo7 &#123; animation: demo7_move 2s linear infinite both; rect &#123; transform-origin: 35px 115px; animation: demo7_rotate .5s linear infinite both; &#125;&#125; 简单位移动画CSS版预览点此；旋转、位移符合动画CSS版预览点此。 五、几个兼容性说明及建议这部分会说一下笔者在开发过程中遇到的一些兼容性问题以及使用建议。当然还会有更多的笔者没遇到的问题，欢迎各位看官多多评论交流，不吝赐教。 总的来说，Snap 的 API 兼容性不错，官网声称兼容 IE9 及以上、Safari、Chrome、Firefox、Opera；而移动设备方面，经笔者测试 iOS、安卓 X5 内核、安卓原生浏览器兼容性都不错，文中的例子除了特殊说明外的都可以执行 作用于 svg 节点的 CSS transform 动画在安卓原生浏览器下兼容性不好， X5 则正常 在 iOS7 和 8 下 innerHTML 方法不能用于 svg 里 安卓原生浏览器绘制 svg 图形很可能会产生渲染模糊的现象（如下图），在 svg 里加上一个 text 节点即可神奇的修复 这样的节点 &lt;text&gt;a&lt;/text&gt; 即可修复模糊的问题，但不能 display:none 隐藏 在使用建议方面： 一般来说，transform 动画可以优先使用 CSS 的方式实现，但如果需要复杂的分段控制或者更好的兼容性，可以试试 Snap 的 transform&amp;matrix 方式 Snap 的有些动画需要大量计算，虽然 svg 里的节点属于“绝对定位”，动画时一般不会引起重排（参考下图），但在移动设备上也要注意动画元素不宜过多。以 image 动画为例， 经笔者测试，150x150 左右的图片动画节点控制在 10 个左右基本能达到大部分机型的性能要求 滤镜类属性在移动设备上不宜做动画 小飞机动画在 chrome 的渲染层边界图： 橙色边为 svg 的边界（即渲染层，为了便于查看 svg 节点经过了 transform:rotateY(30deg) ；绿色为重绘部分。可以看出 svg 里的动画元素只会引起重绘，而里面的节点用 translateZ 也并不会新开一个渲染层。 六、参考资料Snap.svg官网 Web动画API教程5：可爱的运动路径（Motion Path) 张鑫旭：Snap.svg API中文文档兼demo实例页面","pubDate":"Sun, 22 Jan 2017 15:55:00 GMT","guid":"https://aotu.io/notes/2017/01/22/snapsvg/","category":"Web开发"},{"title":"sass-svg 一个内联 SVG 的 SASS 库","link":"https://aotu.io/notes/2017/01/19/sass-svg/","description":"一、CSS内联 SVG一直觉得 内联 SVG 是 HTML 的延伸，但是内联 SVG 往往会造成HTML结构的臃肿。于是笔者尝试着把 SVG 移植到 CSS 中，如下： 12345background: url(&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"393.969\" height=\"28.219\" viewBox=\"0 0 393.969 28.219\"&gt; &lt;path d=\"M0.969,11.313 C-20.207,69.711 314.183,-47.984 393.969,24.312 \"/&gt;&lt;/svg&gt;) 目前（2017.01.12）而言，没有任何浏览器的 CSS 支持内联 SVG 代码，所以上述的代码是一段非法的 css。尽管任何浏览器的 CSS 都不支持内联 SVG 代码，但是所有的现代浏览都是支持内联 SVG 文件，如下： 1background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3NTAgNDAwIj4gCQkJPHBhdGggZD0iTTAsMCBMNzUwLDAgTDc1MCw0MDAgTDM4OCw0MDAgTDM3NSwzODcsIEwzNjIsNDAwIEwwLDQwMFoiIGZpbGw9IiMwZjAiPjwvcGF0aD4gCQk8L3N2Zz4=); 内联 SVG 文件即 Data-URI。 二、Data-URI 简介 A new URL scheme, “data”, is defined. It allows inclusion of small data items as “immediate” data, as if it had been included externally.摘录自：https://tools.ietf.org/html/rfc2397 简单地说，Data-URI 是一种将小文件转换成直接字面数据的方案(scheme)。Data-URI 的语法如下： 1data:[&lt;media type&gt;][;base64],&lt;data&gt; &lt;media type&gt;: 即指定嵌入数据的 MIME，对于 PNG 的图片，其格式是：image/png，如果没有指定，默认是：text/plain；[;base64]: base64 编码扩展，非必选项。如果没指定 base64 编码扩展，后面的 &lt;data&gt; 将使用 URL编码（即百分号编码）。&lt;data&gt;: 编码后的小文件数据。图片文件则是对二进制文件流进行编码，文本文件则是对文本进行编码。 附注：Data-URI 是正式术语，日常中更常用的名字是 Base64。 三、sass-svgsass-svg 是一个将 SVG 代码转化为 Data-URI 的 Sass 库。了解 Data-URI 后，sass-svg 的作用其实就是把 SVG 进行编码的过程。 1. URL编码在 JS 中可以使用 encodeURI 或 encodeURIComponent 来对字符进行 URL 编码，而 Sass 并没有相对就的编码方法。了解一下 URL编码的知识点： URL 编码的原理：ASCII 字符 = % + 两位 ASCII 码（十六进制）。例如，字符 a 对应的 ASCII 码为 0x61，那么 URL 编码后得到 %61。 「rfc3986」规定 URL 只允许英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及保留字符(! * &#39; ( ) ; : @ &amp; = + $ , / ? # [ ])。 尽管 Sass 不提供获取 ASCII 码的函数，但创建一张 ASCII 字符 与 ASCII 码 的对照表(map) 却是廉价的。标准的 ASCII 字符一共是 128 个，剔除 rfc3986 规定的不需要编码的字符（84个），再把扣除一些控制符，实际上需要编码的字符只有 13 个，如下： 12345678910111213141516// ascii 与 16进制对照表$asciiHexMap: ( \" \": \"%09\", \" \": \"%20\", \"\\\"\": \"%22\", \"%\": \"%25\", \"/\": \"%2f\", \"&lt;\": \"%3c\", \"&gt;\": \"%3e\", \"\\\\\": \"%5c\", \"^\": \"%5e\", \"`\": \"%60\", \"&#123;\": \"%7b\", \"|\": \"%7c\", \"&#125;\": \"%7d\"); 实现 URL 编码要求 sass 版本3.3以上，因为需要用到三个内置函数：str_index、str_slice 和 str_insert。 实现 URL 编码的过程不详述，笔者已经将相关代码放到 GIT 仓库，有兴趣的同学可以访问 「sass-svg」。 注意：本文所描述的编码仅针对 US-ASCII 字符集。中文或其它字符不讨论 2. Base64 编码Base64 使用 US-ASCII 子集的64个字符，即大小写的26个英文字母，0～9，＋，/。如下： 12345678'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H','I', 'J', 'K', 'L', 'M', 'N', 'O', 'P','Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f','g', 'h', 'i', 'j', 'k', 'l', 'm', 'n','o', 'p', 'q', 'r', 's', 't', 'u', 'v','w', 'x', 'y', 'z', '0', '1', '2', '3','4', '5', '6', '7', '8', '9', '+', '/' Base64 编码总是基于3个字符，每个字符用8位二进制表示，因此一共24位，再分为4四组，每组6位表示一个 Base64 的值。如果不足3个字符，仍将每个字符对应的二进制串起，再按每组6位表示一个 Base64的值，不足6位的用 0补全，最后生成的 Base64 码不足4位用=补全。 举个例子来感受一下： 与 URL编码相似，SASS 无法直接获取 ASCII 字符对应的二进制，也无法将6位二进制转成 Base64 码。这意味着需要手动创建两张对照表(map)。如下： 123456789101112131415161718192021222324252627// ascii字符 与 8位二进制 对照表$asciiMap: ( \" \": \"00001001\", \" \": \"00100000\", \"!\": \"00100001\", \"\\\"\": \"00100010\", \"#\": \"00100011\", \"$\": \"00100100\", \"%\": \"00100101\", \"&amp;\": \"00100110\", \"'\": \"00100111\", \"(\": \"00101000\", \")\": \"00101001\", \"*\": \"00101010\", \"+\": \"00101011\", \",\": \"00101100\", \"-\": \"00101101\", \".\": \"00101110\", \"/\": \"00101111\", \"0\": \"00110000\", \"1\": \"00110001\", \"2\": \"00110010\", \"3\": \"00110011\", \"4\": \"00110100\", \"5\": \"00110101\", \"6\": \"00110110\", \"7\": \"00110111\", \"8\": \"00111000\", \"9\": \"00111001\", \":\": \"00111010\", \";\": \"00111011\", \"&lt;\": \"00111100\", \"=\": \"00111101\", \"&gt;\": \"00111110\", \"?\": \"00111111\", \"@\": \"01000000\", \"A\": \"01000001\", \"B\": \"01000010\", \"C\": \"01000011\", \"D\": \"01000100\", \"E\": \"01000101\", \"F\": \"01000110\", \"G\": \"01000111\", \"H\": \"01001000\", \"I\": \"01001001\", \"J\": \"01001010\", \"K\": \"01001011\", \"L\": \"01001100\", \"M\": \"01001101\", \"N\": \"01001110\", \"O\": \"01001111\", \"P\": \"01010000\", \"Q\": \"01010001\", \"R\": \"01010010\", \"S\": \"01010011\", \"T\": \"01010100\", \"U\": \"01010101\", \"V\": \"01010110\", \"W\": \"01010111\", \"X\": \"01011000\", \"Y\": \"01011001\", \"Z\": \"01011010\", \"[\": \"01011011\", \"\\\\\": \"01011100\", \"]\": \"01011101\", \"^\": \"01011110\", \"_\": \"01011111\", \"`\": \"01100000\", \"a\": \"01100001\", \"b\": \"01100010\", \"c\": \"01100011\", \"d\": \"01100100\", \"e\": \"01100101\", \"f\": \"01100110\", \"g\": \"01100111\", \"h\": \"01101000\", \"i\": \"01101001\", \"j\": \"01101010\", \"k\": \"01101011\", \"l\": \"01101100\", \"m\": \"01101101\", \"n\": \"01101110\", \"o\": \"01101111\", \"p\": \"01110000\", \"q\": \"01110001\", \"r\": \"01110010\", \"s\": \"01110011\", \"t\": \"01110100\", \"u\": \"01110101\", \"v\": \"01110110\", \"w\": \"01110111\", \"x\": \"01111000\", \"y\": \"01111001\", \"z\": \"01111010\", \"&#123;\": \"01111011\", \"|\": \"01111100\", \"&#125;\": \"01111101\", \"~\": \"01111110\"); 123456789101112131415161718192021// 二进制 与 base64 对照表$base64map: ( \"000000\": 'A', \"000001\": 'B', \"000010\": 'C', \"000011\": 'D', \"000100\": 'E', \"000101\": 'F', \"000110\": 'G', \"000111\": 'H', \"001000\": 'I', \"001001\": 'J', \"001010\": 'K', \"001011\": 'L', \"001100\": 'M', \"001101\": 'N', \"001110\": 'O', \"001111\": 'P', \"010000\": 'Q', \"010001\": 'R', \"010010\": 'S', \"010011\": 'T', \"010100\": 'U', \"010101\": 'V', \"010110\": 'W', \"010111\": 'X', \"011000\": 'Y', \"011001\": 'Z', \"011010\": 'a', \"011011\": 'b', \"011100\": 'c', \"011101\": 'd', \"011110\": 'e', \"011111\": 'f', \"100000\": 'g', \"100001\": 'h', \"100010\": 'i', \"100011\": 'j', \"100100\": 'k', \"100101\": 'l', \"100110\": 'm', \"100111\": 'n', \"101000\": 'o', \"101001\": 'p', \"101010\": 'q', \"101011\": 'r', \"101100\": 's', \"101101\": 't', \"101110\": 'u', \"101111\": 'v', \"110000\": 'w', \"110001\": 'x', \"110010\": 'y', \"110011\": 'z', \"110100\": '0', \"110101\": '1', \"110110\": '2', \"110111\": '3', \"111000\": '4', \"111001\": '5', \"111010\": '6', \"111011\": '7', \"111100\": '8', \"111101\": '9', \"111110\": '+', \"111111\": '/', \"======\": '=' // base64占位符); 实现过程不详述。有兴趣可以访问「sass-svg」。 3. sass-svg 的一个实例开头的非法 CSS，通过 sass-svg 可以改写成： 123456// scssbackground: url( sass-svg-base64('&lt;svg viewBox=\"0 0 393.969 28.219\"&gt; &lt;path d=\"M0.969,11.313 C-20.207,69.711 314.183,-47.984 393.969,24.312 \"/&gt; &lt;/svg&gt;')) 通过编译最终会生成： 1background: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTMuOTY5IDI4LjIxOSI+IAkJICA8cGF0aCBkPSJNMC45NjksMTEuMzEzIEMtMjAuMjA3LDY5LjcxMSAzMTQuMTgzLC00Ny45ODQgMzkzLjk2OSwyNC4zMTIgIi8+IAkJPC9zdmc+\"); 结语感谢阅读本文。关于 sass-svg 的应用，笔者会有后续文章介绍，如果喜欢本文请关注一下我们『凹凸实验室』的微信公众号：AOTULabs 参考资料 Data URI scheme - Wikipedia RFC 2397 - The “data” URL scheme Uniform Resource Identifier (URI): Generic Syntax Uniform Resource Locators (URL) Base64编码解码算法 Module: Sass::Script::Functions URL编码与解码原理 Base64编码解码算法","pubDate":"Thu, 19 Jan 2017 14:21:44 GMT","guid":"https://aotu.io/notes/2017/01/19/sass-svg/","category":"Web开发"},{"title":"微信小程序跨页面通信解决思路","link":"https://aotu.io/notes/2017/01/19/wxapp-event/","description":"宏观上，微信小程序是由一个个 Page 组成的。有时候我们会遇到一些业务存在耦合的 Page，一个 Page 里某个状态改变后，相关 Page 的状态需要进行更新。而在小程序里，每个 Page 都是一个模块，有着独立的作用域，因此 Page 间需要有一种通信策略。 想象一个业务场景，用户首先进入订单列表页。然后点击其中一个订单，进入到订单详情页。当用户在订单详情页对订单进行操作，例如支付、确认收货等时，该订单的状态就会发生改变。此时需要对上一级的订单列表页中该订单的状态进行更新： 要想更新订单列表页的视图层，就需要调用该 Page 对象的 setData 方法。这里为大家列举三种比较常用的方案： 设置标志位最简单的方法，在订单详情页对订单的操作成功回调中，把一些标志位设置为 true，并设置好参数（标志位和参数可以存在 localStorage 或挂在全局 App 对象下）。然后每次在订单列表页的 onShow 生命周期中，根据这些标志位去判断是否进行更新、更新的参数是什么。 这种处理在业务逻辑比较简单、页面间的耦合度很小时还能凑合，一旦逻辑复杂起来，就需要写很多冗余的代码，并且维护成本会非常高。 流程图： 利用页面栈获取 Page 对象如果订单详情页里能拿到订单列表页的 Page 对象，就能去调用它的 setData 方法。小程序提供了一个方法 getCurrentPages，执行它可以得到当前页面栈的实例，然后再根据页面进栈的顺序我们就能拿到订单列表页的 Page 对象。 然而这种做法的缺点还是耦合度太大，过度依赖页面进栈顺序。一旦在以后的产品迭代中页面顺序发生变化，将很难去维护。 流程图： 上述两种方法都存在着耦合度大、维护困难的问题，而利用发布／订阅模式能很好的实现解耦，下面我们先来了解一下这种设计模式。 发布／订阅模式（最优方案）发布／订阅模式由一个发布者、多个订阅者以及一个调度中心所组成。订阅者们先在调度中心订阅某一事件并注册相应的回调函数，当某一时刻发布者发布了一个事件，调度中心会取出订阅了该事件的订阅者们所注册的回调函数来执行。 在发布／订阅模式中，订阅者和发布者并不需要关心对方的状态，订阅者只管订阅事件并注册回调、发布者只管发布事件，其余一切交给调度中心来调度，从而能实现解耦。 在 app 跨页面通信这个问题上，iOS 端的 Notification Center、安卓端的 EventBus，也是通过这样一种设计模式去解决的，不过微信小程序内部并没有提供这种事件通知机制，所以我们需要手动去实现一个。 我们首先要实现一个 Event 类，它应该含有一个收集回调函数的对象，和提供三个基础方法：on（订阅）、 emit（发布）、 off（注销）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// event.jsclass Event &#123; /** * on 方法把订阅者所想要订阅的事件及相应的回调函数记录在 Event 对象的 _cbs 属性中 */ on (event, fn) &#123; if (typeof fn != \"function\") &#123; console.error('fn must be a function') return &#125; this._cbs = this._cbs || &#123;&#125; ;(this._cbs[event] = this._cbs[event] || []).push(fn) &#125; /** * emit 方法接受一个事件名称参数，在 Event 对象的 _cbs 属性中取出对应的数组，并逐个执行里面的回调函数 */ emit (event) &#123; this._cbs = this._cbs || &#123;&#125; var callbacks = this._cbs[event], args if (callbacks) &#123; callbacks = callbacks.slice(0) args = [].slice.call(arguments, 1) for (var i = 0, len = callbacks.length; i &lt; len; i++) &#123; callbacks[i].apply(null, args) &#125; &#125; &#125; /** * off 方法接受事件名称和当初注册的回调函数作参数，在 Event 对象的 _cbs 属性中删除对应的回调函数。 */ off (event, fn) &#123; this._cbs = this._cbs || &#123;&#125; // all if (!arguments.length) &#123; this._cbs = &#123;&#125; return &#125; var callbacks = this._cbs[event] if (!callbacks) return // remove all handlers if (arguments.length === 1) &#123; delete this._cbs[event] return &#125; // remove specific handler var cb for (var i = 0, len = callbacks.length; i &lt; len; i++) &#123; cb = callbacks[i] if (cb === fn || cb.fn === fn) &#123; callbacks.splice(i, 1) break &#125; &#125; return &#125; &#125; 具体调用方法App 是小程序的实例，在每个 Page 里都能通过执行 getApp 函数获取到它。我们可以把 Event 类的实例挂载在 App 中，方便每个 Page 去调用。 12345678// app.jsconst Event = require('./libs/event')App(&#123; event: new Event(), ...&#125;) 订单列表页在 onLoad 生命周期中订阅 “afterPaySuccess” 事件。 12345678910111213//order_list.jsvar app = getApp()Page(&#123; onLoad: function()&#123; app.event.on('afterPaySuccess',this.afterPaySuccess.bind(this)) &#125;, afterPaySuccess: function(orderId) &#123; ... &#125;, ...&#125;) 在订单详情页支付成功的回调中，发布 “afterPaySuccess” 事件,同时带上订单 id 参数。 1234567891011//order_detail.jsvar app = getApp()Page(&#123; raisePayment: function() &#123; ... app.event.emit('afterPaySuccess', orderId) &#125;, ...&#125;) 所有 Page 的 onUnload 生命周期，必须注销掉之前订阅的事件。注销方法 off 的调用姿势有三种，不过还是建议注销当前 Page 所订阅的事件，而不是注销所有的。 12345678910111213var app = getApp()Page(&#123; onUnload: function()&#123; // remove all app.event.off() // remove all callbacks app.event.off('afterPaySuccess') // remove specific callbacks app.event.off('afterPaySuccess', this.afterPaySuccess) &#125;, ...&#125;) 到此就结束了吗？还没有，按照我们的订阅、注销写法，在注销指定回调函数的时候，其实是永远注销不了的。 完善off方法为了让每个回调函数被调用时的 this 都指向对应的 Page 对象，必须在订阅时对回调函数绑定当前的上下文对象。 1app.event.on('afterPaySuccess',this.afterPaySuccess.bind(this)) 相当于 12345app.event.on('afterPaySuccess', function()&#123; var args = Array.prototype.slice.call(arguments) // fn、that分别为闭包起来的回调函数和page对象 return fn.apply(that, args)&#125;) 正因为 bind 方法会返回这样一个匿名函数，然后这个匿名函数会被加入到回调数组中。因此我们注销指定回调函数的时候，在回调数组中是找不到它的，也就永远无法注销。 为了保持我们原来的 emit 调用方式，我想过直接把 Function.prototype.bind 改写： 123456789Function.prototype.bind = function(that) &#123; var fn = this var cb = function()&#123; var args = Array.prototype.slice.call(arguments) return fn.apply(that, args) &#125; cb.fn = this return cb&#125; 然后再稍微修改一下 off 方法里的判断条件 1234567// remove specific callbacks...if (cb === fn || cb.fn === fn) &#123; callbacks.splice(i, 1) break&#125;... 在浏览器环境这种做法是可行的，但是在小程序侧则是失败的。因为我们定义的这些 function 在小程序里并不是 Function 的实例，那无论我怎样修改 Function 的 prototype 属性，function 并不会继承到。原因是小程序把 Function 给改写了： 1234//consoleFunction.toString()// \"function ()&#123;if(arguments.length&gt;0&amp;&amp;\"return this\"===arguments[arguments.length-1])return function()&#123;return e&#125;&#125;\" 优化方案在小程序环境中是不能偷懒了，需要把之前的代码改写一下。要把 Page 对象也传给调度中心保存起来，作为回调函数调用时的上下文对象。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//event.jsclass Event &#123; on (event, fn, ctx) &#123; if (typeof fn != \"function\") &#123; console.error('fn must be a function') return &#125; this._stores = this._stores || &#123;&#125; ;(this._stores[event] = this._stores[event] || []).push(&#123;cb: fn, ctx: ctx&#125;) &#125; emit (event) &#123; this._stores = this._stores || &#123;&#125; var store = this._stores[event], args if (store) &#123; store = store.slice(0) args = [].slice.call(arguments, 1) for (var i = 0, len = store.length; i &lt; len; i++) &#123; store[i].cb.apply(store[i].ctx, args) &#125; &#125; &#125; off (event, fn) &#123; this._stores = this._stores || &#123;&#125; // all if (!arguments.length) &#123; this._stores = &#123;&#125; return &#125; // specific event var store = this._stores[event] if (!store) return // remove all handlers if (arguments.length === 1) &#123; delete this._stores[event] return &#125; // remove specific handler var cb for (var i = 0, len = store.length; i &lt; len; i++) &#123; cb = store[i].cb if (cb === fn) &#123; store.splice(i, 1) break &#125; &#125; return &#125; &#125; 调用方法也需要改一下，不需要使用 bind 方法了，只需传入 Page 对象： 1app.event.on('afterPaySuccess', this.afterPaySuccess, this) 写在最后一个简单的事件类几十行代码就能写完了，但作为一个基础模块还是有很多可以优化和拓展的地方。有兴趣的同学可以研读一下 nodejs 的 event 模块:https://github.com/nodejs/node/blob/master/lib/events.js，里面对事件类做了很多优化和功能拓展。 另外，小程序的开发过程中相信大家都遇到了不少的坑和发现了一些可以优化的点。为了收集这些开发中的痛点，我们开了一个 issue-list：https://github.com/o2team/wxapp-issue-list/blob/master/issue-list.md，欢迎大家前来提 issue~ 参考 https://github.com/dannnney/weapp-event","pubDate":"Thu, 19 Jan 2017 12:27:00 GMT","guid":"https://aotu.io/notes/2017/01/19/wxapp-event/","category":"Web开发"},{"title":"ELF - 灵活可扩展的 HTML5 构建工具","link":"https://aotu.io/notes/2017/01/17/elf/","description":"ELF，意为小精灵，来自 War3 中暗夜精灵族的农民。 通常当我们开始一个新的 HTML5 场景营销活动项目时，需要创建项目目录，初始化基本的项目文件，然后再添加构建（grunt/gulp/webpack）相关的文件（一次两次三次…，像小精灵采木一样~)，目前有不少工具可以帮我们解决一部分这种重复性的工作，但不能完全的解决，于是，就有了小精灵 - ELF，官网：elf.aotu.io。 快速上手 安装 ELF 支持 Node &gt;= 4，通过 npm 全局安装 1npm install -g elf-cli 但是，由于网络的原因，直接安装估计多半都会在安装 node-sass 和 phantomjs 这两个包时失败，所以，强烈推荐使用下面的命令安装 1234# mac/linux$ SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ PHANTOMJS_CDNURL=https://npm.taobao.org/mirrors/phantomjs/ npm install -g elf-cli --registry=https://registry.npm.taobao.org# windows$ npm install -g elf-cli --registry=https://registry.npm.taobao.org --SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ --PHANTOMJS_CDNURL=https://npm.taobao.org/mirrors/phantomjs/ 安装好后，可以运行 elf --help 查看支持的命令和帮助说明。 初始化项目 假如我们现在要做一个向下整页滑屏的 HTML5 项目 12345678# 运行初始化命令，基于 swiper template 初始化项目$ elf init -t swiper demo-swiper# 进入项目目录，安装依赖$ cd demo-swiper &amp;&amp; npm install# 运行（开发模式）$ elf start 这样一个向下整页滑屏的 HTML5 项目就已运行在开发模式上，样式预处理自动编译、样式热加载等功能早已具备， 在此基础上，你就可以开始按照你的需求愉快的开发了。 部署 当项目开发完成之后，需要将代码合并压缩用于部署，运行 1elf build 会生成一个 dist 文件夹用于部署。 整个流程下来，基本解决了 HTML5 项目开发过程中项目初始化和构建部分的重复工作，已在团队内广泛使用，包括 Q4 京东品牌运营的10多个 H5 项目，如 皇家视频 京东精选 功能介绍ELF 主要包括三部分功能：项目构建、示例模板和通用组件。 项目构建现在在做 web 开发时，基本都会引入构建工具，常用的有 grunt、gulp 以及目前最流行的 webpack，再配合各种插件，好处就不多说了，相信每个使用者都有自己的体会和心得。 ELF 基于 webpack 同时整合了 webpack-dev-server sass-loader、less-loader、style-loader html-webpack-plugin postcss-loader、autoprefixer、postcss-plugin-px2rem、postcss-sprites、postcss-assets image-webpack-loader *-loader … 提供了 开发时样式热加载 支持 Sass、Less 和 Stylus 样式预处理自动编译 Autoprefixer 前缀补全 px -&gt; rem 自动转换 雪碧图合成 自动获取图片 width 和 height 部署构建时图片压缩 部署构建时代码合并压缩 有了这些功能，可以让我们在开发时更多的专注于需求实现上。 示例模板目前提供的 5 个模板项目 基础模板（base） 该示例展示了最基本的项目结构，没有提供额外的功能，可以通过该示例了解整个项目的构建 划屏模板（swiper） 滑屏示例，基于 swiper， 可基于该项目初始化实现滑动翻屏的项目。 场景切换模板（switcher） 场景切换示例，基于 swiper 和 anime.js，可基于该项目初始化实现滑动场景切换的项目。 3D全景模板（panorama） 全景示例，基于 three.js 和 orientation.js，可基于该项目初始化实现重力感应配合全景的项目。 视频播放模板（video） 在手机上使用 video 标签播放视频的基础示例。 通过这些示例，可以快速初始化项目，你也可以根据自己的需求，定制自己的初始项目。 通用组件在项目开发中，有些常用功能已被封装成通用组件，例如：swiper。Github 上有大量优秀的开源组件，基本上能满足你所有需求，本着轮子不嫌多的\u0001精神，也造了两个 elf-preloader.js 预加载图片和音频 elf-orientation.js 处理重力感应 欢迎试用并提供问题或优化反馈~~ 写在最后项目最初的形态是由几个整理的典型示例组成，经过两次迭代重构后变成了现在的样子，在开发过程中的灵感主要来自 create-react-app，并借鉴了其 webpack 配置项。后续计划把 示例模板 那块拆分出来（类似 vue-cli 那样以及基于 Electron 提供 GUI。 欢迎各位同学试用，特别是做 HTML5 场景营销活动的同学，如果在使用过程中遇到什么问题，欢迎提交 issues 和 PR,或者 FORK 构建自己的版本。 Github 地址","pubDate":"Tue, 17 Jan 2017 07:26:37 GMT","guid":"https://aotu.io/notes/2017/01/17/elf/","category":"NodeJS"},{"title":"聊聊 SVG 基本形状转换那些事","link":"https://aotu.io/notes/2017/01/16/base-shapes-to-path/","description":"一、前言前段时间研究 SVG 压缩优化，发现SVG预定义的 rect、circle、ellipse、line、polyline、polygon 六种基本形状可通过path路径转换实现，这样可以在一定程度上减少代码量。不仅如此，我们常用的 SVG Path 动画(路径动画)，是以操作path中两个属性值stroke-dasharray和stroke-dashoffset来实现，基本形状转换为path路径，有利于实现路径动画。 二、SVG基本形状SVG 提供了rect、circle、ellipse、line、polyline、polygon六种基本形状用于图形绘制，这些形状可以直接用来绘制一些基本的形状，如矩形、椭圆等，而复杂图形的绘制则需要使用 path 路径来实现。 1.rect 矩形12&lt;rect x=\"10\" y=\"10\" width=\"30\" height=\"30\"/&gt;&lt;rect x=\"60\" y=\"10\" rx=\"10\" ry=\"10\" width=\"30\" height=\"30\"/&gt; SVG中rect元素用于绘制矩形、圆角矩形，含有6个基本属性用于控制矩形的形状以及坐标，具体如下： 123456x 矩形左上角x位置, 默认值为 0 y 矩形左上角y位置, 默认值为 0width 矩形的宽度, 不能为负值否则报错, 0 值不绘制height 矩形的高度, 不能为负值否则报错, 0 值不绘制rx 圆角x方向半径, 不能为负值否则报错ry 圆角y方向半径, 不能为负值否则报错 这里需要注意，rx 和 ry 的还有如下规则： rx 和 ry 都没有设置, 则 rx = 0 ry = 0 rx 和 ry 有一个值为0, 则相当于 rx = 0 ry = 0，圆角无效 rx 和 ry 有一个被设置, 则全部取这个被设置的值 rx 的最大值为 width 的一半, ry 的最大值为 height 的一半 12345678910rx = rx || ry || 0;ry = ry || rx || 0;rx = rx &gt; width / 2 ? width / 2 : rx;ry = ry &gt; height / 2 ? height / 2 : ry;if(0 === rx || 0 === ry)&#123; rx = 0, ry = 0; //圆角不生效，等同于，rx，ry都为0&#125; 2.circle 圆形1&lt;circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"#fff\"&gt;&lt;/circle&gt; SVG中circle元素用于绘制圆形，含有3个基本属性用于控制圆形的坐标以及半径，具体如下： 123r 半径cx 圆心x位置, 默认为 0cy 圆心y位置, 默认为 0 3.ellipse 椭圆1&lt;ellipse cx=\"75\" cy=\"75\" rx=\"20\" ry=\"5\"/&gt; SVG中ellipse元素用于绘制椭圆，是circle元素更通用的形式，含有4个基本属性用于控制椭圆的形状以及坐标，具体如下： 1234rx 椭圆x半径ry 椭圆y半径cx 圆心x位置, 默认为 0cy 圆心y位置, 默认为 0 4.line 直线1&lt;line x1=\"10\" x2=\"50\" y1=\"110\" y2=\"150\"/&gt; Line绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置。 1234x1 起点的x位置y1 起点的y位置x2 终点的x位置y2 终点的y位置 5.polyline 折线1&lt;polyline points=\"60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145\"/&gt; polyline是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中： 1points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2” 6.polygon 多边形1&lt;polygon points=\"50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180\"/&gt; polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形。 1points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2， 路径绘制完闭合图形” 三、SVG path 路径SVG 的路径&lt;path&gt;功能非常强大，它不仅能创建基本形状，还能创建更多复杂的形状。&lt;path&gt;路径是由一些命令来控制的，每一个命令对应一个字母，并且区分大小写，大写主要表示绝对定位，小写表示相对定位。&lt;path&gt; 通过属性 d 来定义路径， d 是一系列命令的集合，主要有以下几个命令： 通常大部分形状，都可以通过指令M(m)、L(l)、H(h)、V(v)、A(a)来实现，注意特别要区分大小写，相对与绝对坐标情况，转换时推荐使用相对路径可减少代码量，例如： 1234567// 以下两个等价d='M 10 10 20 20' // (10, 10) (20 20) 都是绝对坐标d='M 10 10 L 20 20'// 以下两个等价d='m 10 10 20 20' // (10, 10) 绝对坐标, (20 20) 相对坐标d='M 10 10 l 20 20' 四、SVG 基本形状路径转换原理1.rect to path如下图所示，一个 rect 是由 4 个弧和 4 个线段构成；如果 rect 没有设置 rx 和 ry 则 rect 只是由 4 个线段构成。rect 转换为 path 只需要将 A ~ H 之间的弧和线段依次实现即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function rect2path(x, y, width, height, rx, ry) &#123; /* * rx 和 ry 的规则是： * 1. 如果其中一个设置为 0 则圆角不生效 * 2. 如果有一个没有设置则取值为另一个 */ rx = rx || ry || 0; ry = ry || rx || 0; //非数值单位计算，如当宽度像100%则移除 if (isNaN(x - y + width - height + rx - ry)) return; rx = rx &gt; width / 2 ? width / 2 : rx; ry = ry &gt; height / 2 ? height / 2 : ry; //如果其中一个设置为 0 则圆角不生效 if(0 == rx || 0 == ry)&#123; // var path = // 'M' + x + ' ' + y + // 'H' + (x + width) + 不推荐用绝对路径，相对路径节省代码量 // 'V' + (y + height) + // 'H' + x + // 'z'; var path = 'M' + x + ' ' + y + 'h' + width + 'v' + height + 'h' + -width + 'z'; &#125;else&#123; var path = 'M' + x + ' ' + (y+ry) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + rx + ' ' + (-ry) + 'h' + (width - rx - rx) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + rx + ' ' + ry + 'v' + (height - ry -ry) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + (-rx) + ' ' + ry + 'h' + (rx + rx -width) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + (-rx) + ' ' + (-ry) + 'z'; &#125; return path;&#125; 2.circle/ellipse to path圆可视为是一种特殊的椭圆，即 rx 与 ry 相等的椭圆，所以可以放在一起讨论。 椭圆可以看成A点到C做180度顺时针画弧、C点到A做180度顺时针画弧即可。 123456789101112function ellipse2path(cx, cy, rx, ry) &#123; //非数值单位计算，如当宽度像100%则移除 if (isNaN(cx - cy + rx - ry)) return; var path = 'M' + (cx-rx) + ' ' + cy + 'a' + rx + ' ' + ry + ' 0 1 0 ' + 2*rx + ' 0' + 'a' + rx + ' ' + ry + ' 0 1 0 ' + (-2*rx) + ' 0' + 'z'; return path;&#125; 3.line to path相对来说比较简单，如下： 123456789101112function line2path(x1, y1, x2, y2) &#123; //非数值单位计算，如当宽度像100%则移除 if (isNaN(x1 - y1 + x2 - y2)) return; x1 = x1 || 0; y1 = y1 || 0; x2 = x2 || 0; y2 = y2 || 0; var path = 'M' + x1 + ' '+ y1 + 'L' + x2 + ' ' + y2; return path;&#125; 4.polyline/polygon to pathpolyline折线、polygon多边形的转换为path比较类似，差别就是polygon多边形会闭合。 123456789101112131415// polygon折线转换points = [x1, y1, x2, y2, x3, y3 ...];function polyline2path (points) &#123; var path = 'M' + points.slice(0,2).join(' ') + 'L' + points.slice(2).join(' '); return path;&#125;// polygon多边形转换points = [x1, y1, x2, y2, x3, y3 ...];function polygon2path (points) &#123; var path = 'M' + points.slice(0,2).join(' ') + 'L' + points.slice(2).join(' ') + 'z'; return path;&#125; 五、convertpath 转换工具为了方便处理SVG基本元素路径转换，本人抽空写了convertpath工具，具体如下： 安装：1npm i convertpath 使用： 12345678910const parse = require('convertpath');parse.parse(\"./test/test.svg\")/** * &lt;circle cx=\"500\" cy=\"500\" r=\"20\" fill=\"red\"/&gt; */console.log(parse.toSimpleSvg())/** * &lt;path d=\"M500,500,m-20,0,a20,20,0,1,0,40,0,a20,20,0,1,0,-40,0,Z\" fill=\"red\"/&gt; */ 参考资料： Basic Shapes – SVG 1.1 (Second Edition)基本形状 - SVG | MDNSVG (一) 图形, 路径, 变换总结; 以及椭圆弧线, 贝塞尔曲线的详细解释路径 - SVG | MDNXMLDOM","pubDate":"Mon, 16 Jan 2017 04:36:37 GMT","guid":"https://aotu.io/notes/2017/01/16/base-shapes-to-path/","category":"web开发"},{"title":"视频H5のVideo标签在微信里的坑和技巧","link":"https://aotu.io/notes/2017/01/11/mobile-video/","description":"随着 4G 的普遍以及 WiFi 的广泛使用，手机上的网速已经足够稳定和高速，以视频为主的 HTML5 也越来越普遍了，相比帧动画，视频的表现更加丰富，前段时间开发了一个以视频为主的移动端 HTML5，在这里介绍一些实践经验。 统一播放效果我们希望视频播放时可以全屏播放，没有进度条、播放按钮等与系统相关的元素，可以在视频上方增加自定义的元素（比如一个跳过按钮），类型下面的效果： 在不同的操作系统（主要就是 iOS 和 Android），为了达到比较统一的播放效果，分别对其进行兼容。 iOS 在 iOS 上，APP 都是使用的系统自带的浏览器进行页面渲染，video 播放视频的效果是统一的，只需要考虑不同的 iOS 版本是否有不一致的地方。在 iOS 上，播放视频默认会弹出一个播放器全屏播放视频，如下效果 播放器上下有的系统默认的控制栏，可以控制视频的播放进度、音量以及暂停或继续播放，播放视频时，视频会 “浮” 在页面上，页面上的所有元素都只能是在视频下面，这种效果显然不是我们想要的。但好在 iOS 10 Safari 中，video 新增了 playsinline 属性，可以使视频内联播放。 在 webkit 的 blog 上提到 A note about the playsinline attribute: this attribute has recently been added to the HTML specification, and WebKit has adopted this new attribute by unprefixing its legacy webkit-playsinline attribute. This legacy attribute has been supported since iPhoneOS 4.0, and accordance with our updated unprefixing policy, we’re pleased to have been able to unprefix webkit-playsinline. iOS 10 之前的版本支持 webkit-playsinline，但是加了这个属性后，在 iOS 9 的上出现只能听到声音不能看到画面的问题，最后使用的标签代码 1&lt;video id=&quot;video&quot; class=&quot;video&quot; preload=&quot;auto&quot; playsinline src=&quot;http://wqs.jd.com/promote/superfestival/superfestival.mp4&quot; width=&quot;1&quot; height=&quot;1&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt; 然后再加上这个库 iphone-inline-video一起使用。 Android 在 Android 上，因为各个软件使用的浏览器渲染引擎不一样，所以视频播放的效果差异也很大，这里主要以微信为主。微信使用的是自带的渲染引擎 TBS，默认的播放效果 在播放器的下方也是会有控制栏，视频也会 “浮” 在页面上。而 Android 是不支持 playsinline 属性使视频内联播放的。但是，如果你看过一些腾讯的视频类 HTML5，会发现它们在微信里是可以内联播放的，而这个功能是需要申请加入白名单的。 不过新版的 \u0002TBS 内核（&gt;=036849）支持一个叫 同层播放器 的视频播放器，这个不需要申请白名单，只需给 video 设置两个属性 x5-video-player-type=&quot;h5&quot; 和 x5-video-player-fullscreen=&quot;true&quot;，播放效果 当点击左上角的箭头的时，会退出播放 退出播放时，我们需要做相应的处理。TBS 有提供相应的事件，不过不同的版本有一点差异 TBS &lt; 036849 036849 &lt;= TBS &lt; 036900 036900 &lt;= TBS 是否支持同层播放器 否 是 是 退出全屏播放时触发 x5videoenterfullscreen x5videoexitfullscreen 进入全屏播放时触发 x5videoexitfullscreen x5videoenterfullscreen 通过监听这两个事件就可以知道当前的播放状态 1234567document.getElementById('video').addEventListener(\"x5videoexitfullscreen\", function()&#123; alert(\"exit fullscreen\")&#125;)document.getElementById('video').addEventListener(\"x5videoenterfullscreen\", function()&#123; alert(\"enter fullscreen\")&#125;) 在对话框中发送 //gettbs 可以查看相关信息，tbsCoreVersion 就是当前安装的 TBS 内核版本。 video 的事件video 支持的事件很多，但在有些事件在不同的系统上跟预想的表现不一致，在尝试比较之后，使用 timeupdate 和 ended 这两个事件基本可以满足需求 1234567video.addEventListener('timeupdate', function (e) &#123; console.log(video.currentTime) // 当前播放的进度&#125;)video.addEventListener('ended', function (e) &#123; // 播放结束时触发&#125;) 视频居中视频的宽高比是固定的，而手机的屏幕宽高比则不是，所以，为了让观看到的视频的体验尽可能一致，以宽度为先，进行适配 1234567891011121314function handleResize() &#123; var sWidth = 9 var sHeight = 16 var width = window.innerWidth var height = window.innerHeight var marginTop = height - (width * sHeight) / sWidth marginTop = Math.round(marginTop) if (marginTop &lt; -2) &#123; video.$wrapper.css('marginTop', marginTop / 2 + 'px') &#125; else &#123; video.$wrapper.css('marginTop', '0') &#125;&#125; 示例在线示例代码仓库 代码基于 ELF 构建，运行示例需要 安装 ELF，欢迎试用反馈。 参考 https://www.w3.org/wiki/HTML/Elements/video http://caniuse.com/#search=video https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Media_events http://zhaoda.net/2014/10/30/html5-video-optimization https://webkit.org/blog/6784/new-video-policies-for-ios/ https://github.com/bfred-it/iphone-inline-video","pubDate":"Wed, 11 Jan 2017 09:36:37 GMT","guid":"https://aotu.io/notes/2017/01/11/mobile-video/","category":"Web开发"},{"title":"在微信小程序里实现图片预加载组件","link":"https://aotu.io/notes/2017/01/06/wxapp-img-loader/","description":"网页中的图片预加载我们知道在 Web 页面中实现图片的预加载其实很简单，通常的做法是在 JS 中使用 Image 对象即可，代码大致如下 12345var image = new Image()image.onload = function() &#123; console.log('图片加载完成')&#125;image.src = 'http://misc.360buyimg.com/lib/img/e/logo-201305.png' 然而在微信小程序（以下简称小程序）里要实现图片的预加载要更麻烦一些，因为小程序里并没有提供类似 Image 这样的 JS 对象。。 小程序必知必会在进入正题前，需要了解以下小程序相关的知识（当然最好还是完整的学习一下官方文档）： 小程序框架的核心是一个响应的数据绑定系统，整个系统分为视图层和逻辑层两块，视图层即页面模板（后缀为 .wxml 的文件），逻辑层即页面 JS 文件 小程序的页面模板由一系列的基础组件组合而成，如 view、text、button 等 页面内容的更新基于数据的单向绑定来进行，通过 JS 调用 Page 对象的 setData 方法来更新模板中绑定的数据 视图层到逻辑层的通信是通过事件完成的，在组件中声明事件的回调，JS 端可监听到界面交互的发生、组件状态的变化等 在 WXML 文件中，可通过 template 进行模板的复用，若 template 是在不同文件里定义的，需要先通过 import 语句进行引入 这里有个官方的简单例子可以用来帮助理解 123&lt;!-- 模板文件 foo.wxml --&gt;&lt;view&gt; Hello &#123;&#123;name&#125;&#125;! &lt;/view&gt;&lt;button bindtap=\"changeName\"&gt; Click me! &lt;/button&gt; 1234567891011//脚本文件 foo.jsPage(&#123; data: &#123; name: 'WeChat' &#125;, changeName: function(e) &#123; this.setData(&#123; name: 'MINA' &#125;) &#125;&#125;) 运行这个页面会看到一行 Hello WeChat! 的文字及一个按钮，点击按钮后文字会变成 Hello MINA! 在小程序中加载图片小程序提供一个 image 组件（类似于 HTML 中的 img 标签），可以设置 src 及加载成功或失败的回调，使用起来很简单 12&lt;!-- 模板文件 bar.wxml --&gt;&lt;image src=\"http://misc.360buyimg.com/lib/img/e/logo-201305.png\" bindload=\"imageOnLoad\" binderror=\"imageOnLoadError\" /&gt; 123456789//脚本文件 bar.jsPage(&#123; imageOnLoad(ev) &#123; console.log(`图片加载成功，width: $&#123;ev.detail.width&#125;; height: $&#123;ev.detail.height&#125;`) &#125;, imageOnLoadError() &#123; console.log('图片加载失败') &#125;&#125;) 运行以上代码，顺利的话页面上会显示出一张图片，同时控制台会打印出带图片宽高的日志信息 将功能抽离成公用组件接下来我们考虑实现这么一个功能，在页面上载入一张尺寸和 K 数都很大的图片，由于图片很大，下载需要一定的时间，而在这段时间内，用户看到的是空白或是不完整的图片，体验显然不好。 一种常用的优化手段是先加载一张缩略图，该缩略图通过样式设置为和原图一样的宽高，这样用户首先能很快速地看到一张模糊的图片，此时再去对原图做预加载，加载完成之后对缩略图进行替换，因为此时图片已经下载过了，所以界面上能无缝地切换为原图显示，效果如下： 完成这个优化操作的关键就在于需要一个公共的图片预加载组件的支持，接下来我们分步骤来看看如何实现 新建 demo 页面及组件相关的文件 img-loader.js 和 img-loader.wxml，组件需要和页面一样有个模板文件，是因为小程序里无法动态地插入模板结构。然后在 demo.wxml 里通过 import 语句引用组件模板，在 demo.js 里通过 require 语句将组件脚本进行引入 在页面中通过 template 调用组件模板并传入数据，这里我们传递一个名为 imgLoadList 的图片数组过去 在页面脚本中的 onLoad 方法中对组件进行初始化，并将 this 对象传入，因为组件内必须通过 Page 对象的 setData 来更新模板里的内容 在组件的 img-loader.js 中定义一个 load 方法用来创建一个图片的加载，将传入的 src 添加到加载队列中，并使用 setData 方法更新队列数据 接下来在组件 img-loader.wxml 中通过接收到的图片队列数据，用 wx:for 指令去生成 image 组件来对图片进行加载，同时将成功及失败的回调绑定到 img-loader.js 中的方法中，最终再回调回 Page 对象中 可以看出，由于小程序里无法动态地插入模板结构，所以相对于普通网页端的组件调用，这里多出了在 WXML 文件中引入及使用模板这个步骤，而其他部分对于调用方（即Demo 页面）来说则是相似的，下面是完整的 Demo 页面的代码 12345678910111213&lt;!-- demo.wxml --&gt;&lt;view class=\"img_wrap\"&gt; &lt;image wx:if=\"&#123;&#123; imgUrl &#125;&#125;\" src=\"&#123;&#123; imgUrl &#125;&#125;\" /&gt;&lt;/view&gt;&lt;button bindtap=\"loadImage\"&gt;Click To Load Image&lt;/button&gt;&lt;view class=\"msg\"&gt;&#123;&#123; msg &#125;&#125;&lt;/view&gt;&lt;!-- 引入图片预加载组件 --&gt;&lt;import src=\"../../img-loader/img-loader.wxml\"/&gt;&lt;template is=\"img-loader\" data=\"&#123;&#123; imgLoadList &#125;&#125;\"&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536// ------ demo.js ------//引入图片预加载组件const ImgLoader = require('../../img-loader/img-loader.js')//缩略图 80x50 3KBconst imgUrlThumbnail = 'http://storage.360buyimg.com/mtd/home/lion1483683731203.jpg'//原图 3200x2000 1.6MBconst imgUrlOriginal = 'http://storage.360buyimg.com/mtd/home/lion1483624894660.jpg'Page(&#123; data: &#123; msg: '', imgUrl: '' &#125;, onLoad() &#123; //初始化图片预加载组件 this.imgLoader = new ImgLoader(this) &#125;, loadImage() &#123; //加载缩略图 this.setData(&#123; msg: '大图正拼命加载..', imgUrl: imgUrlThumbnail &#125;) //同时对原图进行预加载，加载成功后再替换 this.imgLoader.load(imgUrlOriginal, (err, data) =&gt; &#123; console.log('图片加载完成', err, data.src) this.setData(&#123; msg: '大图加载完成~' &#125;) if (!err) this.setData(&#123; imgUrl: data.src &#125;) &#125;) &#125;&#125;) 如果把图片加载完成的回调统一指定成 Page 对象中的方法，则可以很方便地处理多张图片的加载，这里也写了个例子，效果如下： 总的来说调用起来还算方便吧，img-loader 的组件代码略多这里就不贴出来啦，有兴趣的同学可以前往 Github 项目页面 查看，目前此组件已应用在京东购物小程序版中。Have Fun~","pubDate":"Fri, 06 Jan 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/01/06/wxapp-img-loader/","category":"Web开发"},{"title":"第2季极客沙龙资料分享 - 知行·前端体验主题交流会","link":"https://aotu.io/notes/2017/01/04/geek-talks-s2/","description":"极客沙龙(Geek Talks)，没有固定的主办方，每Q一次，由凹凸实验室联合别的公司、团队一起举办的开放技术分享品牌，面向全栈，核心关注的是移动互联网的技术领域。 本季极客沙龙(Geek Talks) 为鹅厂Fit主办，凹凸实验室、QQ浏览器团队、腾讯TGideas团队联合协办，其主题为「知·行」。 事实上距分享会已过了整整7天，因为我最近拖沓的症状，今天才补上分享会的课件分享。而巧的是，关于治疗拖沓症的具体办法，恰巧可以参考本次分享会来自TGIdeas黄文杰同学分享的「前端开发的自我修养」。 小花絮抽奖签到券用sketch设计的简单抽奖签到券，虽然不是专业设计师，但是还能看吧。 给签到券印上编号心灵手巧的硬妹子EC，凹凸实验室的动效一姐，目前单身！ 茶歇听听分享，吃吃东西。 分享嘉宾合照前段时间「张小龙今天的一张照片，暴露了程序员的审美」刷屏了， 我们的嘉宾显然朝气蓬勃许多吧，左二、三，90后，上个月撸完京东首页改版，右一潮男，右三是会弹吉他的奶爸。 对于审美的话题，引用网友的一句评论：审美在能改变世界的人和金钱面前算个逑。 主题简评及课件下载重构眼中的微信小程序这个分享主要抛出了一种「以现有Web开发构建手段去开发微信小程序」的思路，有点类似「用Reactjs去开发原生APP」的感觉。微信小程序如果真能火起来，将来势必会有很多的开发小程序的工具、系统或框架。 课件下载：重构眼中的微信小程序 京东购物之微信小程序诞生记如果说前面的主题是对小程序的探索和构想，那末这个分享则是实际项目的总结分享。整个讲义非常详细地介绍了「京东购物小程序」的项目背景，分享了开发过程中的坑和技巧。 课件下载：京东购物之微信小程序诞生记 京东首页前端优化之路尽管是后PC时代，但是前端工程化构建以及极致优化的思想一直是热门且通用的课题。 这个分享主要介绍京东首页的整体技术架构和团队开发模式，以及在此次优化过程中所面临的性能、体验、页面可用性等方面的挑战和解决之道。 课件下载：京东首页前端优化之路 前端开发的自我修养 工作中没有脱离项目执行和管理的技术 本次极客沙龙唯一一个非技术性的分享，中间提及的工作思路和感悟可以受用在日常的技术实践过程中。 现在觉得无聊的童鞋可以过两年再回来看看，技术会更新迭代，而修养的话题却是持久不变。 课件下载：前端开发的自我修养 地铁线路图选站实践分享这位同学的SVG玩的很6. SVG在地铁线路图选站项目中的开发实践。技术实现之余，将一起思考探讨在大前端浪潮中，如何选择重构的工作范围，做与不做，一念之间，干系万千。 课件下载：地铁线路图选站实践分享 ServiceWorker介绍了传统WEB开发的痛点，并以DEMO的形式展示了 ServiceWorkers相关技术实践，以及相关进阶扩展和工具配置。 如果没记错，vue2.0的一个有名的开源案例vue-hackernews-2.0 也有SW的实际应用。 课件下载：ServiceWorker 下一季极客沙龙预告第3季将会是「微信小程序专场分享」，今年3月份举办，有兴趣的同学可以关注下。","pubDate":"Wed, 04 Jan 2017 03:35:12 GMT","guid":"https://aotu.io/notes/2017/01/04/geek-talks-s2/","category":"资源合集"}]}