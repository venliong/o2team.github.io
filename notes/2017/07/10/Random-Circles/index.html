<!DOCTYPE html><html class="theme-lattice"><head><meta charset="utf-8"><title>2D圆形随机分布 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="2D圆形随机分布,游戏,Canvas,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2017/07/10/Random-Circles/index.html"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="/img/favicon-230x230.png" sizes="230x230"><link rel="icon" type="image/png" href="/img/android-chrome-192x192.png" sizes="192x192"><link rel="icon" type="image/png" href="/img/android-chrome-144x144.png" sizes="144x144"><link rel="icon" type="image/png" href="/img/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32"><meta name="msapplication-TileColor" content="#2f83cd"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta property="wb:webmaster" content="a1686eb81db284d5"><meta name="wechat-logo" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/cover.gif"><meta name="wechat-title" content="2D圆形随机分布"><meta name="wechat-desc" content="Canvas 上画圈圈诅咒你。"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="如何画出又快又多的圈圈。"><meta name="keywords" content="Canvas,游戏,2D圆形随机分布"><meta property="og:type" content="article"><meta property="og:title" content="2D圆形随机分布"><meta property="og:url" content="https://aotu.io/notes/2017/07/10/Random-Circles/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="如何画出又快又多的圈圈。"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/game.jpg"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_basic.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/points_unavailable.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/circles_cover.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/points_distance.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_testoverlay.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_complete.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_random_algorithm_3.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/radom_circles_diagram_random_and_bfs_algorithm_3.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_and_bfs_after_judge.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_and_bfs_pre_judge.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_y.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/algoritm_compare.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/algorithm_compare_2000.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/hr_machine_io.jpg"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/hr_machine_expertCode.png"><meta property="og:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/hr_machine_code_judge.jpg"><meta property="og:updated_time" content="2017-07-21T01:17:50.802Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="2D圆形随机分布"><meta name="twitter:description" content="如何画出又快又多的圈圈。"><meta name="twitter:image" content="https://misc.aotu.io/lyxuncle/20170710_random_circles/game.jpg"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script><script>window.WechatShareData={imgUrl:"https://misc.aotu.io/lyxuncle/20170710_random_circles/cover.gif",link:window.location.href,title:"2D圆形随机分布",desc:"Canvas 上画圈圈诅咒你。"},window.WechatJSSDKURL="https://aotu.jd.com/aotu-wx-api/api/wx/jssdk/signature"</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://news.aotu.io" class="main-nav-link">资讯</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/cover.gif" alt="2D圆形随机分布"></div><header class="post-hd"><h1 class="post-tit">2D圆形随机分布</h1><div class="post-meta">by <a target="_blank" href="https://github.com/lyxuncle" class="post-author">EC</a> on <span>2017-07-10</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>Canvas 上画圈圈诅咒你。</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><p>如何画出又快又多的圈圈。</p><a id="more"></a><h2 id="命题" class="post-heading"><a href="#命题" class="headerlink" title="命题"></a>命题<a class="post-anchor" href="#命题" aria-hidden="true"></a></h2><p>一个游戏：在一个平面、一定时间内消灭一定的目标。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/game.jpg" alt="游戏截图"></p><p>要实现这个游戏，我们首先要确定，这些元素使用什么形状判定有效点击范围。因为按照图示形状又复杂又没必要，选择一个近似的规则几何图形即可。</p><p>在这里，我们使用圆形作为目标的形状。</p><p>假设世界观是圆形互不重叠。那么会有一下两种可能性：目标大小是否相同；目标是否静止。复杂度依次递增。</p><p>本文主要针对目标大小相同、目标静止的情况进行探讨，并会附上目标大小相同且目标静止、目标大小不同且目标静止两种情况的代码。</p><blockquote><p>本文的探讨不考虑重力因素。有关目标移动的情况，感兴趣的可以参考<a href="https://item.jd.com/10903394.html" target="_blank" rel="external">《HTML5 Canvas 基础教程》</a>。</p></blockquote><h2 id="直线思维" class="post-heading"><a href="#直线思维" class="headerlink" title="直线思维"></a>直线思维<a class="post-anchor" href="#直线思维" aria-hidden="true"></a></h2><p>随机生成一个点，圈好占地范围，继续随机生成一个点，判断是否与之前生成的圆形重叠，如果是，则抛弃，如果不是，则继续。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_basic.png" alt="基础流程图"></p><h3 id="算法" class="post-heading"><a href="#算法" class="headerlink" title="算法"></a>算法<a class="post-anchor" href="#算法" aria-hidden="true"></a></h3><h4 id="生成一个点" class="post-heading"><a href="#生成一个点" class="headerlink" title="生成一个点"></a>生成一个点<a class="post-anchor" href="#生成一个点" aria-hidden="true"></a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 随机生成一个点</div><div class="line"> * @param &#123;w, h&#125; &#123;object&#125; w: 画布宽，h：画布高</div><div class="line"> * @return &#123;x, y&#125; &#123;object&#125; 点坐标</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomPoint</span> (<span class="params">&#123;w, h&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> x = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * w)</div><div class="line">  <span class="keyword">const</span> y = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * h)</div><div class="line">  <span class="keyword">return</span> &#123;x, y&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>随机生成的点要排除两种情况：</p><ul><li>A、距离边界过近。距离边界过近的目标可能出现隐藏部分过多而难以点击甚至无法点击的情况。<br><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/points_unavailable.png" alt="超出边界无效点示意"></li><li>B、与已有点重叠。<br><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/circles_cover.png" alt="重叠与非重叠示意"></li></ul><p>情况A，需要通过合理地设置单位值与无效范围来避免。</p><p>事实上，在0至画布宽度之间随机生成的点保证了目标至少有一半留在画布中。因此第一种情况可以暂时忽略。</p><p>情况B，则涉及到了碰撞检测。</p><h4 id="少壮几何残，老大徒伤悲" class="post-heading"><a href="#少壮几何残，老大徒伤悲" class="headerlink" title="少壮几何残，老大徒伤悲"></a>少壮几何残，老大徒伤悲<a class="post-anchor" href="#少壮几何残，老大徒伤悲" aria-hidden="true"></a></h4><p>节操哥在《<a href="https://aotu.io/notes/2017/02/16/2d-collision-detection/index.html">“等一下，我碰！”——常见的2D碰撞检测</a>》总结了多种碰撞检测的方式。在这里，我们就简单的过一遍圆形碰撞检测的原理。</p><p>这个原理一句话就能概括：两个圆形圆心距离是否大于两个圆形的半径之和。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/points_distance.png" alt="两个圆的碰撞检测示意"></p><p>翻译成坐标语言就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 碰撞检测</div><div class="line"> * @param pointA &#123;object&#125; A目标坐标、半径</div><div class="line"> * @param pointB &#123;object&#125; B目标坐标、半径</div><div class="line"> * @return &#123;boolean&#125; 是否重叠</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testOverlay</span> (<span class="params">pointA, pointB</span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> xGap = <span class="built_in">Math</span>.abs(pointA.x - pointB.x)</div><div class="line">	<span class="keyword">const</span> yGap = <span class="built_in">Math</span>.abs(pointA.y - pointB.y)</div><div class="line">	<span class="keyword">const</span> distance = <span class="built_in">Math</span>.sqrt(xGap * xGap + yGap * yGap)</div><div class="line">	<span class="keyword">const</span> rGap = pointA.r + pointB.r</div><div class="line">	<span class="keyword">return</span> distance &gt;= rGap</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将之应用到整个画布上，则需要遍历现有所有的圆形，以检测新生成的点是否是有效点。</p><p>我们将所有有效点都放入一个数组中，一到碰撞检测时就遍历一次，一旦遇到检测失败的点，则意味着这是个无效点；而一旦整个数组都检测结束，且所有点都与新生成的这个点距离大于半径之和，则这个点才是有效点。</p><p>流程图如下：</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_testoverlay.png" alt="完善流程图"></p><p>对应遍历检测代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 有效点检测</div><div class="line"> * @param pointArr &#123;array&#125; 已有点坐标、半径集合数组</div><div class="line"> * @param newPoint &#123;object&#125; 新点坐标、半径</div><div class="line"> * @return &#123;boolean&#125; 新点是否有效</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAvailable</span> (<span class="params">pointArr, newPoint</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(pointArr)</div><div class="line">  <span class="keyword">let</span> aval = <span class="literal">true</span></div><div class="line">  <span class="keyword">while</span>(arr.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">let</span> lastPoint = arr.pop()</div><div class="line">    <span class="keyword">if</span> (testOverlay(lastPoint, newPoint)) &#123;</div><div class="line">      aval = <span class="literal">false</span></div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> aval</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="放大招" class="post-heading"><a href="#放大招" class="headerlink" title="放大招"></a>放大招<a class="post-anchor" href="#放大招" aria-hidden="true"></a></h4><p>在刚才的流程中，没有做次数限制，结局就是当画布差不多填满的时候，它会一直运行下去，但却再也找不到能填补的空白了。因此我们需要对它的尝试次数做一个限制，增加一个计数器，每尝试一次加一。</p><p>完善了最初的流程图，我们可以得到：</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_complete.png" alt="完善流程图"></p><p>将碰撞检测的流程加进去，就是这样子的——</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_circles_diagram_random_algorithm_3.png" alt="随机算法完整流程图"></p><p>按照这个流程图撸代码，思路清晰到飞起哦～</p><p>完整代码：</p><ul><li><a href="https://codepen.io/lyxuncle/pen/GEyXWq" target="_blank" rel="external">固定半径</a><br><p data-height="265" data-theme-id="0" data-slug-hash="GEyXWq" data-default-tab="js,result" data-user="lyxuncle" data-embed-version="2" data-pen-title="随机平铺圆形" class="codepen">See the Pen <a href="https://codepen.io/lyxuncle/pen/GEyXWq/" target="_blank" rel="external">随机平铺圆形</a> by EC (<a href="https://codepen.io/lyxuncle" target="_blank" rel="external">@lyxuncle</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></li><li><a href="https://codepen.io/lyxuncle/pen/YQYBZQ" target="_blank" rel="external">随机半径</a><br><p data-height="265" data-theme-id="0" data-slug-hash="YQYBZQ" data-default-tab="js,result" data-user="lyxuncle" data-embed-version="2" data-pen-title="随机平铺圆形（随机半径）" class="codepen">See the Pen <a href="https://codepen.io/lyxuncle/pen/YQYBZQ/" target="_blank" rel="external">随机平铺圆形（随机半径）</a> by EC (<a href="https://codepen.io/lyxuncle" target="_blank" rel="external">@lyxuncle</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></li></ul><h2 id="另一种解法" class="post-heading"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法<a class="post-anchor" href="#另一种解法" aria-hidden="true"></a></h2><p>其实上面的算法，已经够小游戏用了。但我们换个思路，是不是会得到更加优秀的代码君呢？</p><p>随机生成一个点，圈好占地范围。然后再这个点的周围，寻找N个有效目标，直到没有地方为止。然后再在这个点周围生成的有效点的周围寻找有效点，直到再也找不到其他有效点为止。</p><p>这个时候，再到画布范围随机生成一个点，然后重复上一步。直到画布没有位置了为止。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/radom_circles_diagram_random_and_bfs_algorithm_3.png" alt="广搜算法与随机算法结合流程图"></p><p>这种算法我们暂且将之称为广搜算法（<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="external">广度优先搜索</a>，Breadth First Search，BFS）与随机算法的结合。</p><h3 id="生成相对随机点" class="post-heading"><a href="#生成相对随机点" class="headerlink" title="生成相对随机点"></a>生成相对随机点<a class="post-anchor" href="#生成相对随机点" aria-hidden="true"></a></h3><p>生成相对随机点的思路其实是碰撞检测的逆推，首先在有效范围内生成一个 x（或 y）点，同时在有效范围内随机生成一个半径值，根据这两个值，计算出对应的 y（或 x）点。</p><h4 id="x-（或-y）轴的有效范围" class="post-heading"><a href="#x-（或-y）轴的有效范围" class="headerlink" title="x （或 y）轴的有效范围"></a>x （或 y）轴的有效范围<a class="post-anchor" href="#x-（或-y）轴的有效范围" aria-hidden="true"></a></h4><p>我们以 x 轴坐标为例。</p><p>大家看到，上面的方法描述中，对于坐标的要求是在“有效范围”生成。对于这个有效范围，第一反应就是以相对点为中心，在两个目标半径之和间的范围。</p><p>但是，在第一种算法中，由于 x 与 y 的取值永远在画布范围内，因此能保证至少4/1个圆形出现在画布中，不影响用户的定位与操作。但在这种算法中，由于是相对取点，如果相对位置已经处于画布边缘，那就有极大的可能出现随机产生的相对点过于超出画布的情况。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_and_bfs_after_judge.png" alt=""></p><p>我们可以通过两种方法来解决这个问题：<br>一、在有效范围可以确定的情况下，提前排除这种情况，可以减少无效点生成的次数。这种方法的劣势在于增加了算法复杂度。我们姑且将它称为坐标预判断的算法。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_and_bfs_pre_judge.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 生成相对随机点</div><div class="line"> * @param prev &#123;object&#125; 参照点坐标、半径</div><div class="line"> * @param size &#123;object&#125; 画布长宽、半径范围</div><div class="line"> * @return &#123;object&#125; 新点坐标、半径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRelativePoint</span> (<span class="params">prev, size</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; maxR, minR&#125; = size</div><div class="line">  <span class="keyword">const</span> nextR = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (maxR - minR) + minR)</div><div class="line">  <span class="keyword">const</span> dia = prev.r + nextR</div><div class="line">  <span class="keyword">const</span> xGap = prev.x - dia &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.random() * (prev.x + dia) : prev.x + dia &gt; size.w ? <span class="built_in">Math</span>.random() * (size.w - prev.x + dia) : <span class="built_in">Math</span>.random() * (dia * <span class="number">2</span>)</div><div class="line">  <span class="keyword">const</span> x = prev.x - dia &lt; <span class="number">0</span> ? <span class="built_in">parseInt</span>(xGap) : <span class="built_in">parseInt</span>(xGap + prev.x - dia)</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中对于 x 的随机生成做了限制。如图所示，如果相对目标超出了边界，则将随机范围划定为边界至 x 加上两目标半径之和这个绝对距离之间。</p><p>二、在判断有效点的逻辑中增加坐标是否超出画布（或者更为苛刻）的判断。这种方法也增加了算法复杂度，但比上一个方法少了一些计算量，不过会有更多的无效点生成，消耗计数器的计数，可能会导致更多的空白区域。这个算法我们起名坐标后判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 生成相对随机点</div><div class="line"> * @param prev &#123;object&#125; 参照点坐标、半径</div><div class="line"> * @param radius &#123;number&#125; 固定半径</div><div class="line"> * @return &#123;object&#125; 新点坐标、半径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRelativePoint</span> (<span class="params">prev, radius</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> dia = radius * <span class="number">2</span></div><div class="line">  <span class="keyword">const</span> xGap = <span class="built_in">Math</span>.random() * (dia * <span class="number">2</span>)</div><div class="line">  <span class="keyword">const</span> x = <span class="built_in">parseInt</span>(xGap + prev.x - dia)</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="依赖已生成-x（或-y）轴坐标推导出-y（或-x）轴坐标" class="post-heading"><a href="#依赖已生成-x（或-y）轴坐标推导出-y（或-x）轴坐标" class="headerlink" title="依赖已生成 x（或 y）轴坐标推导出 y（或 x）轴坐标"></a>依赖已生成 x（或 y）轴坐标推导出 y（或 x）轴坐标<a class="post-anchor" href="#依赖已生成-x（或-y）轴坐标推导出-y（或-x）轴坐标" aria-hidden="true"></a></h4><p>在这个步骤里，需要考虑的是，根据已知坐标与已知半径值，可以得出两个 y （或 x）轴坐标。对于这两个可能坐标，需要再做一次随机处理。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/random_y.png" alt="随机y轴坐标示意图"></p><p>以 y 轴坐标的求值为例。</p><p>首先，求得三角形三边中的 b 边长度。</p><p>接着，随机出一个正负值，然后求得最终的 y 轴坐标。</p><p>同样的，坐标预判断方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 生成相对随机点（随机半径）</div><div class="line"> * @param prev &#123;object&#125; 参照点坐标、半径</div><div class="line"> * @param size &#123;object&#125; 画布长宽、半径范围</div><div class="line"> * @return &#123;object&#125; 新点坐标、半径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRelativePoint</span> (<span class="params">prev, size</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; maxR, minR&#125; = size</div><div class="line">  <span class="keyword">const</span> nextR = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (maxR - minR) + minR)</div><div class="line">  <span class="keyword">const</span> dia = prev.r + nextR</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">const</span> sign = <span class="built_in">Math</span>.random() - <span class="number">0.5</span> &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span></div><div class="line">  <span class="keyword">const</span> yGap = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.sqrt(dia * dia - (prev.x - x) * (prev.x - x)))</div><div class="line">  <span class="keyword">const</span> y = prev.y - yGap &lt; <span class="number">0</span> ? prev.y + yGap : prev.y + yGap &gt; size.h ? prev.y - yGap : yGap * sign + prev.y</div><div class="line">  <span class="keyword">return</span> &#123;x, y, <span class="attr">r</span>: nextR&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>坐标后判断方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 生成相对随机点</div><div class="line"> * @param prev &#123;object&#125; 参照点坐标、半径</div><div class="line"> * @param radius &#123;number&#125; 固定半径</div><div class="line"> * @return &#123;object&#125; 新点坐标、半径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRelativePoint</span> (<span class="params">prev, radius</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> dia = radius * <span class="number">2</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">const</span> sign = <span class="built_in">Math</span>.random() - <span class="number">0.5</span> &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span></div><div class="line">  <span class="keyword">const</span> yGap = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.sqrt(dia * dia - (prev.x - x) * (prev.x - x)))</div><div class="line">  <span class="keyword">const</span> y = yGap * sign + prev.y</div><div class="line">  <span class="keyword">return</span> &#123;x, y&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>合到一起，就得到一个生成相对随机点的方法。</p><p>坐标预判断方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 生成相对随机点（随机半径）</div><div class="line"> * @param prev &#123;object&#125; 参照点坐标、半径</div><div class="line"> * @param size &#123;object&#125; 画布长宽、半径范围</div><div class="line"> * @return &#123;object&#125; 新点坐标、半径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRelativePoint</span> (<span class="params">prev, size</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; maxR, minR&#125; = size</div><div class="line">  <span class="keyword">const</span> nextR = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (maxR - minR) + minR)</div><div class="line">  <span class="keyword">const</span> dia = prev.r + nextR</div><div class="line">  <span class="keyword">const</span> xGap = prev.x - dia &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.random() * (prev.x + dia) : prev.x + dia &gt; size.w ? <span class="built_in">Math</span>.random() * (size.w - prev.x + dia) : <span class="built_in">Math</span>.random() * (dia * <span class="number">2</span>)</div><div class="line">  <span class="keyword">const</span> x = prev.x - dia &lt; <span class="number">0</span> ? <span class="built_in">parseInt</span>(xGap) : <span class="built_in">parseInt</span>(xGap + prev.x - dia)</div><div class="line">  <span class="keyword">const</span> sign = <span class="built_in">Math</span>.random() - <span class="number">0.5</span> &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span></div><div class="line">  <span class="keyword">const</span> yGap = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.sqrt(dia * dia - (prev.x - x) * (prev.x - x)))</div><div class="line">  <span class="keyword">const</span> y = prev.y - yGap &lt; <span class="number">0</span> ? prev.y + yGap : prev.y + yGap &gt; size.h ? prev.y - yGap : yGap * sign + prev.y</div><div class="line">  <span class="keyword">return</span> &#123;x, y, <span class="attr">r</span>: nextR&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>坐标后判断方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @desc 生成相对随机点</div><div class="line"> * @param prev &#123;object&#125; 参照点坐标、半径</div><div class="line"> * @param &#123;minR, maxR&#125; &#123;object&#125; 半径范围</div><div class="line"> * @return &#123;object&#125; 新点坐标、半径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRelativePoint</span> (<span class="params">prev, radius</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> dia = radius * <span class="number">2</span></div><div class="line">  <span class="keyword">const</span> xGap = <span class="built_in">Math</span>.random() * (dia * <span class="number">2</span>)</div><div class="line">  <span class="keyword">const</span> x = <span class="built_in">parseInt</span>(xGap + prev.x - dia)</div><div class="line">  <span class="keyword">const</span> sign = <span class="built_in">Math</span>.random() - <span class="number">0.5</span> &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span></div><div class="line">  <span class="keyword">const</span> yGap = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.sqrt(dia * dia - (prev.x - x) * (prev.x - x)))</div><div class="line">  <span class="keyword">const</span> y = yGap * sign + prev.y</div><div class="line">  <span class="keyword">return</span> &#123;x, y&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完整代码：</p><ul><li><a href="https://codepen.io/lyxuncle/pen/jwzxXG" target="_blank" rel="external">固定半径</a><br><p data-height="265" data-theme-id="0" data-slug-hash="jwzxXG" data-default-tab="js,result" data-user="lyxuncle" data-embed-version="2" data-pen-title="随机平铺圆形（广搜+随机）" class="codepen">See the Pen <a href="https://codepen.io/lyxuncle/pen/jwzxXG/" target="_blank" rel="external">随机平铺圆形（广搜+随机）</a> by EC (<a href="https://codepen.io/lyxuncle" target="_blank" rel="external">@lyxuncle</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></li><li>随机半径<ul><li><a href="https://codepen.io/lyxuncle/pen/GEYqZJ" target="_blank" rel="external">算法一：坐标预判断</a><br><p data-height="265" data-theme-id="0" data-slug-hash="GEYqZJ" data-default-tab="js,result" data-user="lyxuncle" data-embed-version="2" data-pen-title="随机平铺圆形（广搜+随机，随机半径。相对随机点算法2）" class="codepen">See the Pen <a href="https://codepen.io/lyxuncle/pen/GEYqZJ/" target="_blank" rel="external">随机平铺圆形（广搜+随机，随机半径。相对随机点算法2）</a> by EC (<a href="https://codepen.io/lyxuncle" target="_blank" rel="external">@lyxuncle</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></li><li><a href="https://codepen.io/lyxuncle/pen/XgqZJP" target="_blank" rel="external">算法二：坐标后判断</a><br><p data-height="265" data-theme-id="0" data-slug-hash="XgqZJP" data-default-tab="js,result" data-user="lyxuncle" data-embed-version="2" data-pen-title="随机平铺圆形（广搜+随机，随机半径。坐标后判断）" class="codepen">See the Pen <a href="https://codepen.io/lyxuncle/pen/XgqZJP/" target="_blank" rel="external">随机平铺圆形（广搜+随机，随机半径。坐标后判断）</a> by EC (<a href="https://codepen.io/lyxuncle" target="_blank" rel="external">@lyxuncle</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></li></ul></li></ul><h2 id="两种算法的对比" class="post-heading"><a href="#两种算法的对比" class="headerlink" title="两种算法的对比"></a>两种算法的对比<a class="post-anchor" href="#两种算法的对比" aria-hidden="true"></a></h2><blockquote><p>由于广搜算法与随机算法结合中随机半径的两种算法效率差距较为明显，因此只取坐标后判断算法与随机算法对比。</p></blockquote><p>在320x550的画布上，两种算法的效率差距不大，覆盖率（也就是密度）的差距在10%以内，相当于多画了4-5个左右圈。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/algoritm_compare.png" alt=""></p><p>但在2000x2000的画布上，随机算法的效率就远高于两种算法结合的效率。在随机半径的情况下，两种算法结合的方法有时甚至需要1s的时间。而覆盖率的差距依然在10%以内，由于画布的增大，意味着圈的数量差距也随之增加。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/algorithm_compare_2000.png" alt=""></p><h2 id="游戏中的算法" class="post-heading"><a href="#游戏中的算法" class="headerlink" title="游戏中的算法"></a>游戏中的算法<a class="post-anchor" href="#游戏中的算法" aria-hidden="true"></a></h2><p>Human Resource Machine 是一个汇编编程的小游戏，通过罗列代码段来完成游戏中的命题。从最简单的 in/out，到简单的数值计算，再到最后的排序算法的实现，而仅有11个编程语句可以使用。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/hr_machine_io.jpg" alt=""></p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/hr_machine_expertCode.png" alt=""></p><p>每一关都会对你编写的代码进行数量与效率的评估，你所要做到的就是对数量与效率兼顾到最好。</p><p><img src="https://misc.aotu.io/lyxuncle/20170710_random_circles/hr_machine_code_judge.jpg" alt=""></p><p>通过这个游戏，会让你对底层数据的存储与处理有比较深的了解，同时对代码的优化进行追根溯源。</p><p>有人说这游戏真是反人类，现在的代码都讲究的是可读性，以这个游戏的评判标准，有时候是要以牺牲可读性为代价的。但在这种极端的情况下比较容易激发大家对于算法的探索与思考，跳出思维定式，以便找到更佳甚至最佳算法。毕竟，人家只是个游戏（虽然过几天你再打开代码也许就看不懂了）。</p><h2 id="完整范例" class="post-heading"><a href="#完整范例" class="headerlink" title="完整范例"></a>完整范例<a class="post-anchor" href="#完整范例" aria-hidden="true"></a></h2><p><a href="http://jdc.jd.com/demo/if_food_had_voice_chips/chips.html" target="_blank" rel="external">食在会玩</a></p><blockquote><p>范例中的代码使用的是第二种算法。从画布面积来看效率上是没啥问题的，但其实当时是从第一种算法改为第二种算法的，因为当时使用的第一种算法并没有这次 demo 整理出来的那样顺利。阿婆主也不明白发生了什么，也许是因为没画流程图吧[抠鼻]。</p></blockquote><div class="post-tags" style="display:none"><a href="/tags/Canvas/">Canvas</a> <a href="/tags/游戏/">游戏</a> <a href="/tags/2D圆形随机分布/">2D圆形随机分布</a></div><div class="post-categories" style="display:none"><a href="/cates/Web开发/">Web开发</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2017/07/10/Random-Circles/">https://aotu.io/notes/2017/07/10/Random-Circles/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2017-07-21T01:17:50.802Z">上次更新：2017-07-21 09:17:50</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2017/07/17/design-a-swiper/" title="实现一个 Swiper">实现一个 Swiper <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2017/06/29/motion-detection/" title="用Web技术实现移动监测"><i class="fa fa-chevron-left"></i> 用Web技术实现移动监测</a></div></div><div class="post-comments" id="comments"></div><script>var gitmentOpts={id:"bm90ZXMvMjAxNy8wNy8xMC9SYW5kb20tQ2lyY2xlcy8=",owner:"mamboer",repo:"gitment.aotu.io",link:"https://aotu.io/notes/2017/07/10/Random-Circles/index.html",title:"2D圆形随机分布",desc:"Canvas 上画圈圈诅咒你。",oauth:{client_id:"3c4d153e6874260f9c7e",client_secret:"dd44012504c6168bc05b9266e0554bb28c62ce15"}}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周五推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2017. All Rights Reserved.</p><p><a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitment.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script><script>!function(e,t,o,n,a,c,i){e.alogObjectName=a,e[a]=e[a]||function(){(e[a].q=e[a].q||[]).push(arguments)},e[a].l=1*new Date,c=t.createElement(o),i=t.getElementsByTagName(o)[0],c.async=1,c.src="//wqs.jd.com/promote/quark/atlogs.2.0.min.js",i.parentNode.insertBefore(c,i)}(window,document,"script",0,"ATlog"),ATlog("init",{app_key:"aotu-blog-aotu.io-011",clickEvents:!0,mta:!0})</script></body></html>